# Dry-run Prompt
## Metadata
### Token Summary
```
Instruction Tokens:                   24,837
Simulated User Prompt Tokens:         15,689
Simulated Assistent Response Tokens:   7,903
New User Prompt Tokens:                6,777
Total Tokens:                         80,206
Model Max Tokens:                    100,000

```
## Instructions
Convert a given TypeScript code file containing a AWS CDK unit tests to TerraConstruct unit tests, following specified guidance and examples.
Ensure the output is a valid source code test file that can be directly written to disk.
Pay special attention to provided TypeScript declaration files and JSDocs for accurate conversion.

## Conversion Guidelines

- Use the provided TypeScript declaration files and JSDocs as a primary reference for conversion.
- Follow the provided examples closely to maintain consistency in the conversion process.
- Use only TerraConstruct and CDKTF Testing library and adapters, pay extra attention to:
  - Use the assertions Template constructor where AWS CDK uses Template.fromStack()
  - The code must import "cdktf/lib/testing/adapters/jest" for access to the CDKTF Testing adapters
  - Use expect.toHaveResourceWithProperties where AWS CDK uses hasResourceProperties
  - Use Jest's toMatchObject Matcher where AWS CDK uses templateMatches()
  - Prefer using stack.resolve() instead of resource names in assertions
  - Resource naming differences, TerraConstructs generates
- Pay close attention to the Terraform Docs for the expected resource field names (snake_case, not TitleCase)
- Do do NOT implement ContextProvider Lookup tests, but highlight they are missing in the conversion

## Reference Documents

**TerraConstructs Testing Declarations**
```typescript
// ../../assertions
import { TerraformStack, StackAnnotation } from "cdktf";
import { TerraformConstructor } from "cdktf/lib/testing/matchers";
export interface SynthOptions {
    /**
     * snapshot full synthesized template
     */
    snapshot?: boolean;
    /**
     * Run all validations on the stack before synth
     */
    runValidations?: boolean;
}
/**
 * Helper class to create Jest Matchers for a TerraformStack
 */
export declare class Template {
    /**
     * Create Jest Matchers from the parsed synthesized spec
     *
     * Best for common Jest Matchers
     *
     * This always runs TerraformStack.prepareStack() as this
     * library heavily depends on it for pre-synth resource
     * generation.
     */
    static fromStack(stack: TerraformStack, options?: SynthOptions): jest.JestMatchers<any>;
    /**
     * Create Jest Matchers for the synthesized JSON string
     *
     * Required by the CDKTF Jest Matchers (toHaveResourceWithProperties, ...)
     *
     * This always runs TerraformStack.prepareStack() as this
     * library heavily depends on it for pre-synth resource
     * generation.
     */
    static synth(stack: TerraformStack, options?: SynthOptions): jest.JestMatchers<any>;
    static expectStacksEqual(stack1: TerraformStack, stack2: TerraformStack): void;
    /**
     * Create Jest Matchers for stack resources of a specific type
     *
     * This always runs TerraformStack.prepareStack() as this
     * library heavily depends on it for pre-synth resource
     * generation.
     */
    static resources(stack: TerraformStack, type: TerraformConstructor, options?: SynthOptions): jest.JestMatchers<object[]>;
    /**
     * Get stack resources by type
     */
    static resourceObjects(stack: TerraformStack, type: TerraformConstructor, options?: SynthOptions): object;
    /**
     * Create Jest Matchers for stack outputs of a specific type
     *
     * This always runs TerraformStack.prepareStack() as this
     * library heavily depends on it for pre-synth resource
     * generation.
     */
    static dataSources(stack: TerraformStack, type: TerraformConstructor, options?: SynthOptions): jest.JestMatchers<object[]>;
    /**
     * Create Jest Matchers for a specific stack output or
     * throw an error if the output is not found
     *
     * This always runs TerraformStack.prepareStack() as this
     * library heavily depends on it for pre-synth resource
     * generation.
     */
    static expectOutput(stack: TerraformStack, outputName: string, options?: SynthOptions): jest.JestMatchers<object | undefined>;
    private static getSynthString;
    private readonly raw;
    private readonly template;
    constructor(stack: TerraformStack, options?: SynthOptions);
    get expect(): jest.JestMatchers<any>;
    toMatchObject(o: object): void;
    get resource(): object | undefined;
    /**
     * Get an Object of resources by type,
     * the key is the resource name and the value is the resource object
     */
    resourcesByType(type: TerraformConstructor): object;
    /**
     * Get an Array of resources by type, discarding the resource names
     */
    resourceTypeArray(type: TerraformConstructor): Array<object>;
    /**
     * Jest Matcher for resourceTypeArray
     *
     * shortcut for expect(template.resourceTypeArray(type))
     */
    expectResources(type: TerraformConstructor): jest.JestMatchers<any>;
    resourceCountIs(type: TerraformConstructor, count: number): void;
    resourceTypeArrayContaining(type: TerraformConstructor, object: any): void;
    resourceTypeArrayNotContaining(type: TerraformConstructor, object: any): void;
    get data(): object | undefined;
    dataSourcesByType(type: TerraformConstructor): object;
    /**
     * Get an Array of datasources by type, discarding the resource names
     */
    dataSourceTypeArray(type: TerraformConstructor): Array<object>;
    get output(): object | undefined;
    outputByName(name: string): object | undefined;
}
export declare class Annotations {
    private readonly annotations;
    static fromStack(stack: TerraformStack): Annotations;
    private constructor();
    get warnings(): StackAnnotation[];
    get errors(): StackAnnotation[];
    /**
     * check if the stack has a warning for certain context path and message
     */
    hasWarnings(...expectedWarnings: Array<Partial<StackAnnotationMatcher>>): void;
    /**
     * ensure the stack has no warning for certain context path and message
     */
    hasNoWarnings(...expectedWarnings: Array<Partial<StackAnnotationMatcher>>): void;
    private warningMatcher;
    /**
     * check if the stack has an error for certain context path and message
     */
    hasErrors(...expectedErrors: Array<Partial<StackAnnotationMatcher>>): void;
}
export interface StackAnnotationMatcher {
    constructPath: string | RegExp;
    message: string | RegExp;
}


// ../../jest
import { TerraformConstructor } from "../matchers";
declare global {
    namespace jest {
        interface Matchers<R> {
            toHaveResource(resourceConstructor: TerraformConstructor): R;
            toHaveResourceWithProperties(resourceConstructor: TerraformConstructor, properties: Record<string, any>): R;
            toHaveDataSource(dataSourceConstructor: TerraformConstructor): R;
            toHaveDataSourceWithProperties(dataSourceConstructor: TerraformConstructor, properties: Record<string, any>): R;
            toHaveProvider(providerConstructor: TerraformConstructor): R;
            toHaveProviderWithProperties(providerConstructor: TerraformConstructor, properties: Record<string, any>): R;
            toBeValidTerraform(): R;
            toPlanSuccessfully(): R;
        }
    }
}
export declare function setupJest(): void;


// ../../index
import { App, TerraformStack } from "../../lib";
import { IConstruct, Construct } from "constructs";
export interface IScopeCallback {
    (scope: Construct): void;
}
export interface TestingAppConfig {
    readonly outdir?: string;
    readonly stackTraces?: boolean;
    readonly stubVersion?: boolean;
    readonly enableFutureFlags?: boolean;
    readonly fakeCdktfJsonPath?: boolean;
}
/**
 * Testing utilities for cdktf applications.
 */
export declare class Testing {
    /**
     * Returns an app for testing with the following properties:
     * - Output directory is a temp dir.
     */
    static app(options?: TestingAppConfig): App;
    static stubVersion(app: App): App;
    static fakeCdktfJsonPath(app: App): App;
    static enableFutureFlags(app: App): App;
    static synthScope(fn: IScopeCallback): string;
    /**
     * Returns the Terraform synthesized JSON.
     */
    static synth(stack: TerraformStack, runValidations?: boolean): string;
    static fullSynth(stack: TerraformStack): string;
    static renderConstructTree(construct: IConstruct): string;
    static toHaveDataSourceWithProperties(received: string, resourceType: string, properties?: Record<string, any>): boolean;
    static toHaveDataSource(received: string, resourceType: string): boolean;
    static toHaveResourceWithProperties(received: string, resourceType: string, properties?: Record<string, any>): boolean;
    static toHaveResource(received: string, resourceType: string): boolean;
    static toHaveProviderWithProperties(received: string, resourceType: string, properties?: Record<string, any>): boolean;
    static toHaveProvider(received: string, resourceType: string): boolean;
    static toBeValidTerraform(received: string): boolean;
    static setupJest(): void;
}

```

**TerraConstructs AWS Core Declarations**
```typescript
// ../../../src/aws/arn
import { IAwsStack } from "./aws-stack";
/**
 * An enum representing the various ARN formats that different services use.
 */
export declare enum ArnFormat {
    /**
     * This represents a format where there is no 'resourceName' part.
     * This format is used for S3 resources,
     * like 'arn:aws:s3:::bucket'.
     * Everything after the last colon is considered the 'resource',
     * even if it contains slashes,
     * like in 'arn:aws:s3:::bucket/object.zip'.
     */
    NO_RESOURCE_NAME = "arn:aws:service:region:account:resource",
    /**
     * This represents a format where the 'resource' and 'resourceName'
     * parts are separated with a colon.
     * Like in: 'arn:aws:service:region:account:resource:resourceName'.
     * Everything after the last colon is considered the 'resourceName',
     * even if it contains slashes,
     * like in 'arn:aws:apigateway:region:account:resource:/test/mydemoresource/*'.
     */
    COLON_RESOURCE_NAME = "arn:aws:service:region:account:resource:resourceName",
    /**
     * This represents a format where the 'resource' and 'resourceName'
     * parts are separated with a slash.
     * Like in: 'arn:aws:service:region:account:resource/resourceName'.
     * Everything after the separating slash is considered the 'resourceName',
     * even if it contains colons,
     * like in 'arn:aws:cognito-sync:region:account:identitypool/us-east-1:1a1a1a1a-ffff-1111-9999-12345678:bla'.
     */
    SLASH_RESOURCE_NAME = "arn:aws:service:region:account:resource/resourceName",
    /**
     * This represents a format where the 'resource' and 'resourceName'
     * parts are seperated with a slash,
     * but there is also an additional slash after the colon separating 'account' from 'resource'.
     * Like in: 'arn:aws:service:region:account:/resource/resourceName'.
     * Note that the leading slash is _not_ included in the parsed 'resource' part.
     */
    SLASH_RESOURCE_SLASH_RESOURCE_NAME = "arn:aws:service:region:account:/resource/resourceName"
}
export interface ArnComponents {
    /**
     * The partition that the resource is in. For standard AWS regions, the
     * partition is aws. If you have resources in other partitions, the
     * partition is aws-partitionname. For example, the partition for resources
     * in the China (Beijing) region is aws-cn.
     *
     * @default The AWS partition the stack is deployed to.
     */
    readonly partition?: string;
    /**
     * The service namespace that identifies the AWS product (for example,
     * 's3', 'iam', 'codepipline').
     */
    readonly service: string;
    /**
     * The region the resource resides in. Note that the ARNs for some resources
     * do not require a region, so this component might be omitted.
     *
     * @default The region the stack is deployed to.
     */
    readonly region?: string;
    /**
     * The ID of the AWS account that owns the resource, without the hyphens.
     * For example, 123456789012. Note that the ARNs for some resources don't
     * require an account number, so this component might be omitted.
     *
     * @default The account the stack is deployed to.
     */
    readonly account?: string;
    /**
     * Resource type (e.g. "table", "autoScalingGroup", "certificate").
     * For some resource types, e.g. S3 buckets, this field defines the bucket name.
     */
    readonly resource: string;
    /**
     * Separator between resource type and the resource.
     *
     * Can be either '/', ':' or an empty string. Will only be used if resourceName is defined.
     * @default '/'
     *
     * @deprecated use arnFormat instead
     */
    readonly sep?: string;
    /**
     * Resource name or path within the resource (i.e. S3 bucket object key) or
     * a wildcard such as ``"*"``. This is service-dependent.
     */
    readonly resourceName?: string;
    /**
     * The specific ARN format to use for this ARN value.
     *
     * @default - uses value of `sep` as the separator for formatting,
     *   `ArnFormat.SLASH_RESOURCE_NAME` if that property was also notd
     */
    readonly arnFormat?: ArnFormat;
}
export declare class Arn {
    /**
     * Creates an ARN from components.
     *
     * If `partition`, `region` or `account` are not specified, the stack's
     * partition, region and account will be used.
     *
     * If any component is the empty string, an empty string will be inserted
     * into the generated ARN at the location that component corresponds to.
     *
     * The ARN will be formatted as follows:
     *
     *   arn:{partition}:{service}:{region}:{account}:{resource}{sep}{resource-name}
     *
     * The required ARN pieces that are omitted will be taken from the stack that
     * the 'scope' is attached to. If all ARN pieces are supplied, the supplied scope
     * can be 'undefined'.
     */
    static format(components: ArnComponents, stack?: IAwsStack): string;
    /**
     * Given an ARN, parses it and returns components.
     *
     * IF THE ARN IS A CONCRETE STRING...
     *
     * ...it will be parsed and validated. The separator (`sep`) will be set to '/'
     * if the 6th component includes a '/', in which case, `resource` will be set
     * to the value before the '/' and `resourceName` will be the rest. In case
     * there is no '/', `resource` will be set to the 6th components and
     * `resourceName` will be set to the rest of the string.
     *
     * IF THE ARN IS A TOKEN...
     *
     * ...it cannot be validated, since we don't have the actual value yet at the
     * time of this function call. You will have to supply `sepIfToken` and
     * whether or not ARNs of the expected format usually have resource names
     * in order to parse it properly. The resulting `ArnComponents` object will
     * contain tokens for the subexpressions of the ARN, not string literals.
     *
     * If the resource name could possibly contain the separator char, the actual
     * resource name cannot be properly parsed. This only occurs if the separator
     * char is '/', and happens for example for S3 object ARNs, IAM Role ARNs,
     * IAM OIDC Provider ARNs, etc. To properly extract the resource name from a
     * Tokenized ARN, you must know the resource type and call
     * `Arn.extractResourceName`.
     *
     * @param arn The ARN to parse
     * @param sepIfToken The separator used to separate resource from resourceName
     * @param hasName Whether there is a name component in the ARN at all. For
     * example, SNS Topics ARNs have the 'resource' component contain the topic
     * name, and no 'resourceName' component.
     *
     * @returns an ArnComponents object which allows access to the various
     * components of the ARN.
     *
     * @returns an ArnComponents object which allows access to the various
     *      components of the ARN.
     *
     * @deprecated use split instead
     */
    static parse(arn: string, sepIfToken?: string, hasName?: boolean): ArnComponents;
    /**
     * Splits the provided ARN into its components.
     * Works both if 'arn' is a string like 'arn:aws:s3:::bucket',
     * and a Token representing a dynamic CloudFormation expression
     * (in which case the returned components will also be dynamic CloudFormation expressions,
     * encoded as Tokens).
     *
     * @param arn the ARN to split into its components
     * @param arnFormat the expected format of 'arn' - depends on what format the service 'arn' represents uses
     */
    static split(arn: string, arnFormat: ArnFormat): ArnComponents;
    /**
     * Extract the full resource name from an ARN
     *
     * Necessary for resource names (paths) that may contain the separator, like
     * `arn:aws:iam::111111111111:role/path/to/role/name`.
     *
     * Only works if we statically know the expected `resourceType` beforehand, since we're going
     * to use that to split the string on ':<resourceType>/' (and take the right-hand side).
     *
     * We can't extract the 'resourceType' from the ARN at hand, because CloudFormation Expressions
     * only allow literals in the 'separator' argument to `{ Fn::Split }`, and so it can't be
     * `{ Fn::Select: [5, { Fn::Split: [':', ARN] }}`.
     *
     * Only necessary for ARN formats for which the type-name separator is `/`.
     */
    static extractResourceName(arn: string, resourceType: string): string;
    private constructor();
}


// ../../../src/aws/aws-construct
import { Construct } from "constructs";
import { AwsStack } from "./aws-stack";
import { TerraConstructBase, TerraConstructProps, ITerraConstruct } from "../construct-base";
/**
 * Represents the environment a given AwsConstruct lives in.
 * Used as the return value for the `IResource.env` property.
 */
export interface AwsEnvironment {
    /**
     * The AWS partition that this resource belongs to.
     */
    readonly partition: string;
    /**
     * The AWS account ID that this resource belongs to.
     */
    readonly account: string;
    /**
     * The AWS region that this resource belongs to.
     */
    readonly region: string;
}
/**
 * Represents an AWS resource similar to the AWS CDK `Resource` class but backed by CDKTF.
 */
export interface IAwsConstruct extends ITerraConstruct {
    /**
     * The stack into which this resource is constructed by the TerraConstruct.
     */
    readonly stack: AwsStack;
    /**
     * The environment this resource belongs to.
     * For resources that are created and managed by the CDKTF
     * (generally, those created by creating new class instances like Environment, EcsDeployment, etc.),
     * this is always the same as the environment of the stack they belong to;
     * however, for imported resources
     * (those obtained from static methods like fromRoleArn, fromBucketName, etc.),
     * that might be different than the stack they were imported into.
     */
    readonly env: AwsEnvironment;
}
/**
 * Construction properties for `Resource`.
 */
export interface AwsConstructProps extends TerraConstructProps {
    /**
     * The AWS account ID this resource belongs to.
     *
     * @default - the resource is in the same account as the stack it belongs to
     */
    readonly account?: string;
    /**
     * The AWS region this resource belongs to.
     *
     * @default - the resource is in the same region as the stack it belongs to
     */
    readonly region?: string;
    /**
     * ARN to deduce region and account from
     *
     * The ARN is parsed and the account and region are taken from the ARN.
     * This should be used for imported resources.
     *
     * Cannot be supplied together with either `account` or `region`.
     *
     * @default - take environment from `account`, `region` parameters, or use Stack environment.
     */
    readonly environmentFromArn?: string;
}
/**
 * Represents an AWS resource similar to the AWS CDK `Resource` class but backed by CDKTF.
 */
export declare abstract class AwsConstructBase extends TerraConstructBase implements IAwsConstruct {
    readonly stack: AwsStack;
    readonly env: AwsEnvironment;
    constructor(scope: Construct, id: string, props?: AwsConstructProps);
}


// ../../../src/aws/aws-stack
import { provider } from "@cdktf/provider-aws";
import { ResourceTerraformIterator } from "cdktf";
import { Construct, IConstruct } from "constructs";
import { ArnComponents, ArnFormat } from "./arn";
import { AwsProviderConfig } from "./provider-config.generated";
import { StackBaseProps, StackBase, IStack } from "../stack-base";
export interface AwsStackProps extends StackBaseProps {
    /**
     * The AWS Provider configuration (without the alias field)
     */
    readonly providerConfig: AwsProviderConfig;
}
export interface IAwsStack extends IStack {
    /**
     * The AWS Region for the TerraConstruct
     */
    readonly region: string;
    /**
     * The AWS Account for the TerraConstruct
     */
    readonly account: string;
    /**
     * The AWS Partition for the TerraConstruct
     */
    readonly partition: string;
    /**
     * The service Principal Id for a specific service
     *
     * @param serviceName The service name to get the service principal ID for
     * @param region The region to get the service principal ID for
     */
    servicePrincipalName(serviceName: string, region?: string): string;
}
/**
 * A Terraform stack constrained to a single AWS Account/Region to simulate CFN behavior.
 */
export declare class AwsStack extends StackBase implements IAwsStack {
    /**
     * Return whether the given object is a Stack.
     *
     * attribute detection since as 'instanceof' potentially fails across Library releases.
     */
    static isAwsStack(x: any): x is AwsStack;
    /**
     * Looks up the first stack scope in which `construct` is defined. Fails if there is no stack up the tree or the stack is not an AwsStack.
     * @param construct The construct to start the search from.
     */
    static ofAwsConstruct(construct: IConstruct): AwsStack;
    private readonly lookup;
    private regionalAwsProviders;
    /**
     * Cache these tokens for reliable comparisons.
     *
     * Every call for the same Token will produce a new unique string, no
     * attempt is made to deduplicate. Token objects should cache the
     * value themselves, if required.
     *
     * dataSource.getSTringattribute -> Token.asString -> tokenMap.registerString
     * ref:
     * - https://github.com/hashicorp/terraform-cdk/blob/v0.20.10/packages/cdktf/lib/terraform-data-source.ts#L68
     * - https://github.com/hashicorp/terraform-cdk/blob/v0.20.10/packages/cdktf/lib/tokens/private/token-map.ts#L50-L66
     */
    private _accountIdToken;
    private _paritionToken;
    private _urlSuffixToken;
    constructor(scope: Construct, id: string, props: AwsStackProps);
    get provider(): provider.AwsProvider;
    /**
     * Get the Region of the AWS Stack
     */
    get region(): string;
    private get dataAwsCallerIdentity();
    private get dataAwsAvailabilityZones();
    private get dataAwsPartition();
    private getRegionalAwsProvider;
    /**
     * Get the Account of the AWS Stack
     */
    get account(): string;
    /**
     * Get the Partition of the AWS Stack
     */
    get partition(): string;
    /**
     * Base DNS domain name for the current partition (e.g., amazonaws.com in AWS Commercial, amazonaws.com.cn in AWS China).
     */
    get urlSuffix(): string;
    /**
     * Return the service principal name based on the region it's used in.
     *
     * Some service principal names used to be different for different partitions,
     * and some were not.
     *
     * These days all service principal names are standardized, and they are all
     * of the form `<servicename>.amazonaws.com`.
     *
     * To avoid breaking changes, handling is provided for services added with the formats below,
     * however, no additional handling will be added for new regions or partitions.
     *   - s3
     *   - s3.amazonaws.com
     *   - s3.amazonaws.com.cn
     *   - s3.c2s.ic.gov
     *   - s3.sc2s.sgov.gov
     *
     * @param service The service name to get the service principal ID for
     * @param region The region to get the service principal ID for
     */
    servicePrincipalName(service: string, region?: string): string;
    /**
     * Creates an ARN from components.
     *
     * If `partition`, `region` or `account` are not specified, the stack's
     * partition, region and account will be used.
     *
     * If any component is the empty string, an empty string will be inserted
     * into the generated ARN at the location that component corresponds to.
     *
     * The ARN will be formatted as follows:
     *
     *   arn:{partition}:{service}:{region}:{account}:{resource}{sep}{resource-name}
     *
     * The required ARN pieces that are omitted will be taken from the stack that
     * the 'scope' is attached to. If all ARN pieces are supplied, the supplied scope
     * can be 'undefined'.
     */
    formatArn(components: ArnComponents): string;
    /**
     * Given an ARN, parses it and returns components.
     *
     * IF THE ARN IS A CONCRETE STRING...
     *
     * ...it will be parsed and validated. The separator (`sep`) will be set to '/'
     * if the 6th component includes a '/', in which case, `resource` will be set
     * to the value before the '/' and `resourceName` will be the rest. In case
     * there is no '/', `resource` will be set to the 6th components and
     * `resourceName` will be set to the rest of the string.
     *
     * IF THE ARN IS A TOKEN...
     *
     * ...it cannot be validated, since we don't have the actual value yet at the
     * time of this function call. You will have to supply `sepIfToken` and
     * whether or not ARNs of the expected format usually have resource names
     * in order to parse it properly. The resulting `ArnComponents` object will
     * contain tokens for the subexpressions of the ARN, not string literals.
     *
     * If the resource name could possibly contain the separator char, the actual
     * resource name cannot be properly parsed. This only occurs if the separator
     * char is '/', and happens for example for S3 object ARNs, IAM Role ARNs,
     * IAM OIDC Provider ARNs, etc. To properly extract the resource name from a
     * Tokenized ARN, you must know the resource type and call
     * `Arn.extractResourceName`.
     *
     * @param arn The ARN string to parse
     * @param sepIfToken The separator used to separate resource from resourceName
     * @param hasName Whether there is a name component in the ARN at all. For
     * example, SNS Topics ARNs have the 'resource' component contain the topic
     * name, and no 'resourceName' component.
     *
     * @returns an ArnComponents object which allows access to the various
     * components of the ARN.
     *
     * @returns an ArnComponents object which allows access to the various
     *      components of the ARN.
     *
     * @deprecated use splitArn instead
     */
    parseArn(arn: string, sepIfToken?: string, hasName?: boolean): ArnComponents;
    /**
     * Splits the provided ARN into its components.
     * Works both if 'arn' is a string like 'arn:aws:s3:::bucket',
     * and a Token representing a dynamic CloudFormation expression
     * (in which case the returned components will also be dynamic CloudFormation expressions,
     * encoded as Tokens).
     *
     * @param arn the ARN to split into its components
     * @param arnFormat the expected format of 'arn' - depends on what format the service 'arn' represents uses
     */
    splitArn(arn: string, arnFormat: ArnFormat): ArnComponents;
    /**
     * Returns iterator for all AZs that are available in the AWS environment
     * (account/region) associated with this stack (default or aliased provider).
     *
     * this will return a cdktf iterator
     *
     * https://developer.hashicorp.com/terraform/cdktf/concepts/iterators#define-iterators
     *
     * To specify a different strategy for selecting availability zones override this method.
     */
    get availabilityZoneIterator(): ResourceTerraformIterator;
    /**
     * Returns a List of Tokens for AZ names available in the stack's
     * AWS environment (account/region).
     *
     * The list length is `maxCount` which defaults to 2.
     *
     * @param maxCount the maximum number of AZs to return
     */
    availabilityZones(maxCount?: number): string[];
}


// ../../../src/aws/aws-tags
import { IAspect } from "cdktf";
import { IConstruct } from "constructs";
import { TaggableConstruct } from "../construct-base";
/**
 * TaggableConstruct is a Construct that can have tags
 */
export declare function isTaggableConstruct(x: IConstruct): x is TaggableConstruct;
/**
 * Properties for a tag
 */
export interface TagProps {
    /**
     * An array of Resource Types that will not receive this tag
     *
     * An empty array will allow this tag to be applied to all resources. A
     * non-empty array will apply this tag only if the Resource type is not in
     * this array.
     * @default []
     */
    readonly excludeResourceTypes?: string[];
    /**
     * An array of Resource Types that will receive this tag
     *
     * An empty array will match any Resource. A non-empty array will apply this
     * tag only to Resource types that are included in this array.
     * @default []
     */
    readonly includeResourceTypes?: string[];
}
/**
 * CDKTF Aspect adding a single Key/Value Tag to all resources within a construct scope
 *
 * Add tags using `Tags.of(scope).add(key, value)`
 */
export declare class AwsTag implements IAspect {
    private key;
    private value;
    private readonly props;
    constructor(key: string, value: string, props?: TagProps);
    visit(node: IConstruct): void;
    private applyTagAspectHere;
}
/**
 * Manages AWS tags for all resources within a construct scope.
 */
export declare class Tags {
    private readonly scope;
    /**
     * Returns the tags API for this scope.
     * @param scope The scope
     */
    static of(scope: IConstruct): Tags;
    private constructor();
    /**
     * add tags to the node of a construct and all its the taggable children
     */
    add(key: string, value: string, props?: TagProps): void;
}


// ../../../src/aws/log-retention
/**
 * How long, in days, the log contents will be retained.
 */
export declare enum RetentionDays {
    /**
     * 1 day
     */
    ONE_DAY = 1,
    /**
     * 3 days
     */
    THREE_DAYS = 3,
    /**
     * 5 days
     */
    FIVE_DAYS = 5,
    /**
     * 1 week
     */
    ONE_WEEK = 7,
    /**
     * 2 weeks
     */
    TWO_WEEKS = 14,
    /**
     * 1 month
     */
    ONE_MONTH = 30,
    /**
     * 2 months
     */
    TWO_MONTHS = 60,
    /**
     * 3 months
     */
    THREE_MONTHS = 90,
    /**
     * 4 months
     */
    FOUR_MONTHS = 120,
    /**
     * 5 months
     */
    FIVE_MONTHS = 150,
    /**
     * 6 months
     */
    SIX_MONTHS = 180,
    /**
     * 1 year
     */
    ONE_YEAR = 365,
    /**
     * 13 months
     */
    THIRTEEN_MONTHS = 400,
    /**
     * 18 months
     */
    EIGHTEEN_MONTHS = 545,
    /**
     * 2 years
     */
    TWO_YEARS = 731,
    /**
     * 3 years
     */
    THREE_YEARS = 1096,
    /**
     * 5 years
     */
    FIVE_YEARS = 1827,
    /**
     * 6 years
     */
    SIX_YEARS = 2192,
    /**
     * 7 years
     */
    SEVEN_YEARS = 2557,
    /**
     * 8 years
     */
    EIGHT_YEARS = 2922,
    /**
     * 9 years
     */
    NINE_YEARS = 3288,
    /**
     * 10 years
     */
    TEN_YEARS = 3653,
    /**
     * Retain logs forever
     */
    INFINITE = 9999
}


// ../../../src/aws/provider-config.generated
import type { IResolvable } from 'cdktf';
import type { provider } from '@cdktf/provider-aws';
/**
 * Config for the AWS Provider
 */
export interface AwsProviderConfig {
    /**
     * Resolve an endpoint with FIPS capability.
     * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs#use_fips_endpoint AwsProvider#use_fips_endpoint}
     * @stability stable
     */
    readonly useFipsEndpoint?: boolean | IResolvable;
    /**
     * Resolve an endpoint with DualStack capability.
     * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs#use_dualstack_endpoint AwsProvider#use_dualstack_endpoint}
     * @stability stable
     */
    readonly useDualstackEndpoint?: boolean | IResolvable;
    /**
     * The capacity of the AWS SDK's token bucket rate limiter.
     * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs#token_bucket_rate_limiter_capacity AwsProvider#token_bucket_rate_limiter_capacity}
     * @stability stable
     */
    readonly tokenBucketRateLimiterCapacity?: number;
    /**
     * session token. A session token is only required if you are using temporary security credentials.
     * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs#token AwsProvider#token}
     * @stability stable
     */
    readonly token?: string;
    /**
     * The region where AWS STS operations will take place. Examples are us-east-1 and us-west-2.
     * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs#sts_region AwsProvider#sts_region}
     * @stability stable
     */
    readonly stsRegion?: string;
    /**
     * Skip requesting the account ID. Used for AWS API implementations that do not have IAM/STS API and/or metadata API.
     * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs#skip_requesting_account_id AwsProvider#skip_requesting_account_id}
     * @stability stable
     */
    readonly skipRequestingAccountId?: boolean | IResolvable;
    /**
     * Skip static validation of region name.
     * Used by users of alternative AWS-like APIs or users w/ access to regions that are not public (yet).
     *
     * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs#skip_region_validation AwsProvider#skip_region_validation}
     * @stability stable
     */
    readonly skipRegionValidation?: boolean | IResolvable;
    /**
     * Skip the AWS Metadata API check. Used for AWS API implementations that do not have a metadata api endpoint.
     * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs#skip_metadata_api_check AwsProvider#skip_metadata_api_check}
     * @stability stable
     */
    readonly skipMetadataApiCheck?: string;
    /**
     * Skip the credentials validation via STS API. Used for AWS API implementations that do not have STS available/implemented.
     * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs#skip_credentials_validation AwsProvider#skip_credentials_validation}
     * @stability stable
     */
    readonly skipCredentialsValidation?: boolean | IResolvable;
    /**
     * List of paths to shared credentials files. If not set, defaults to [~/.aws/credentials].
     * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs#shared_credentials_files AwsProvider#shared_credentials_files}
     * @stability stable
     */
    readonly sharedCredentialsFiles?: Array<string>;
    /**
     * List of paths to shared config files. If not set, defaults to [~/.aws/config].
     * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs#shared_config_files AwsProvider#shared_config_files}
     * @stability stable
     */
    readonly sharedConfigFiles?: Array<string>;
    /**
     * The secret key for API operations. You can retrieve this from the 'Security & Credentials' section of the AWS console.
     * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs#secret_key AwsProvider#secret_key}
     * @stability stable
     */
    readonly secretKey?: string;
    /**
     * Set this to true to enable the request to use path-style addressing, i.e., https://s3.amazonaws.com/BUCKET/KEY. By default, the S3 client will use virtual hosted bucket addressing when possible (https://BUCKET.s3.amazonaws.com/KEY). Specific to the Amazon S3 service.
     * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs#s3_use_path_style AwsProvider#s3_use_path_style}
     * @stability stable
     */
    readonly s3UsePathStyle?: boolean | IResolvable;
    /**
     * Specifies whether S3 API calls in the `us-east-1` region use the legacy global endpoint or a regional endpoint.
     * Valid values are `legacy` or `regional`. Can also be configured using the `AWS_S3_US_EAST_1_REGIONAL_ENDPOINT` environment variable or the `s3_us_east_1_regional_endpoint` shared config file parameter
     *
     * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs#s3_us_east_1_regional_endpoint AwsProvider#s3_us_east_1_regional_endpoint}
     * @stability stable
     */
    readonly s3UsEast1RegionalEndpoint?: string;
    /**
     * Specifies how retries are attempted.
     * Valid values are `standard` and `adaptive`. Can also be configured using the `AWS_RETRY_MODE` environment variable.
     *
     * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs#retry_mode AwsProvider#retry_mode}
     * @stability stable
     */
    readonly retryMode?: string;
    /**
     * The region where AWS operations will take place. Examples are us-east-1, us-west-2, etc.
     * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs#region AwsProvider#region}
     * @stability stable
     */
    readonly region?: string;
    /**
     * The profile for API operations. If not set, the default profile created with `aws configure` will be used.
     * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs#profile AwsProvider#profile}
     * @stability stable
     */
    readonly profile?: string;
    /**
     * Comma-separated list of hosts that should not use HTTP or HTTPS proxies.
     * Can also be set using the `NO_PROXY` or `no_proxy` environment variables.
     *
     * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs#no_proxy AwsProvider#no_proxy}
     * @stability stable
     */
    readonly noProxy?: string;
    /**
     * The maximum number of times an AWS API request is being executed.
     * If the API request still fails, an error is
     * thrown.
     *
     * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs#max_retries AwsProvider#max_retries}
     * @stability stable
     */
    readonly maxRetries?: number;
    /**
     * Explicitly allow the provider to perform "insecure" SSL requests. If omitted, default value is `false`.
     * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs#insecure AwsProvider#insecure}
     * @stability stable
     */
    readonly insecure?: boolean | IResolvable;
    /**
     * ignore_tags block.
     * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs#ignore_tags AwsProvider#ignore_tags}
     * @stability stable
     */
    readonly ignoreTags?: IResolvable | Array<provider.AwsProviderIgnoreTags>;
    /**
     * URL of a proxy to use for HTTPS requests when accessing the AWS API.
     * Can also be set using the `HTTPS_PROXY` or `https_proxy` environment variables.
     *
     * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs#https_proxy AwsProvider#https_proxy}
     * @stability stable
     */
    readonly httpsProxy?: string;
    /**
     * URL of a proxy to use for HTTP requests when accessing the AWS API.
     * Can also be set using the `HTTP_PROXY` or `http_proxy` environment variables.
     *
     * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs#http_proxy AwsProvider#http_proxy}
     * @stability stable
     */
    readonly httpProxy?: string;
    /**
     * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs#forbidden_account_ids AwsProvider#forbidden_account_ids}.
     * @stability stable
     */
    readonly forbiddenAccountIds?: Array<string>;
    /**
     * endpoints block.
     * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs#endpoints AwsProvider#endpoints}
     * @stability stable
     */
    readonly endpoints?: IResolvable | Array<provider.AwsProviderEndpoints>;
    /**
     * Protocol to use with EC2 metadata service endpoint.Valid values are `IPv4` and `IPv6`. Can also be configured using the `AWS_EC2_METADATA_SERVICE_ENDPOINT_MODE` environment variable.
     * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs#ec2_metadata_service_endpoint_mode AwsProvider#ec2_metadata_service_endpoint_mode}
     * @stability stable
     */
    readonly ec2MetadataServiceEndpointMode?: string;
    /**
     * Address of the EC2 metadata service endpoint to use. Can also be configured using the `AWS_EC2_METADATA_SERVICE_ENDPOINT` environment variable.
     * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs#ec2_metadata_service_endpoint AwsProvider#ec2_metadata_service_endpoint}
     * @stability stable
     */
    readonly ec2MetadataServiceEndpoint?: string;
    /**
     * default_tags block.
     * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs#default_tags AwsProvider#default_tags}
     * @stability stable
     */
    readonly defaultTags?: IResolvable | Array<provider.AwsProviderDefaultTags>;
    /**
     * File containing custom root and intermediate certificates.
     * Can also be configured using the `AWS_CA_BUNDLE` environment variable. (Setting `ca_bundle` in the shared config file is not supported.)
     *
     * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs#custom_ca_bundle AwsProvider#custom_ca_bundle}
     * @stability stable
     */
    readonly customCaBundle?: string;
    /**
     * assume_role_with_web_identity block.
     * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs#assume_role_with_web_identity AwsProvider#assume_role_with_web_identity}
     * @stability stable
     */
    readonly assumeRoleWithWebIdentity?: IResolvable | Array<provider.AwsProviderAssumeRoleWithWebIdentity>;
    /**
     * assume_role block.
     * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs#assume_role AwsProvider#assume_role}
     * @stability stable
     */
    readonly assumeRole?: IResolvable | Array<provider.AwsProviderAssumeRole>;
    /**
     * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs#allowed_account_ids AwsProvider#allowed_account_ids}.
     * @stability stable
     */
    readonly allowedAccountIds?: Array<string>;
    /**
     * The access key for API operations. You can retrieve this from the 'Security & Credentials' section of the AWS console.
     * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/aws/5.88.0/docs#access_key AwsProvider#access_key}
     * @stability stable
     */
    readonly accessKey?: string;
}


// ../../../src/aws/util
/**
 * Returns a copy of `obj` without `undefined` (or `null`) values in maps or arrays.
 */
export declare function filterUndefined(obj: any): any;

```

## Steps

1. **Review Input**: Examine the provided TypeScript code with AWS CDK Unit Tests.
2. **Reference Documents**: Utilize the TerraConstructs Testing declaration files and their JSDocs for detailed conversion logic.
3. **Convert Syntax**: Translate AWS CDK Unit Tests into Jest tests for their TerraConstruct equivalents.
4. **Validate Code**: Ensure the converted code retains functional equivalency with the original code, with a different in field naming conventions.
5. **Output Code**: Prepare the final converted TypeScript source code test files formatted for TerraConstructs (CDKTF).

## Output Format

- Generate a TypeScript source code test file (.test.ts) formatted for CDKTF.
- Ensure the file is syntactically correct and ready for writing to disk.
- put the source code between triple back ticks ("```")

## Examples

**Example 1:**
**Input**:
```typescript
import { testDeprecated } from '@aws-cdk/cdk-build-tools';
import { Template } from '../../assertions';
import * as iam from '../../aws-iam';
import * as kms from '../../aws-kms';
import * as sqs from '../../aws-sqs';
import { Aws, CfnResource, Stack, Arn, App, PhysicalName, CfnOutput } from '../../core';
import { EventBus } from '../lib';

describe('event bus', () => {
  test('default event bus', () => {
    // GIVEN
    const stack = new Stack();

    // WHEN
    new EventBus(stack, 'Bus');

    // THEN
    Template.fromStack(stack).hasResourceProperties('AWS::Events::EventBus', {
      Name: 'Bus',
    });
  });

  test('default event bus with empty props object', () => {
    // GIVEN
    const stack = new Stack();

    // WHEN
    new EventBus(stack, 'Bus', {});

    // THEN
    Template.fromStack(stack).hasResourceProperties('AWS::Events::EventBus', {
      Name: 'Bus',
    });
  });

  test('named event bus', () => {
    // GIVEN
    const stack = new Stack();

    // WHEN
    new EventBus(stack, 'Bus', {
      eventBusName: 'myEventBus',
    });

    // THEN
    Template.fromStack(stack).hasResourceProperties('AWS::Events::EventBus', {
      Name: 'myEventBus',
    });
  });

  test('event bus with description', () => {
    // GIVEN
    const stack = new Stack();

    // WHEN
    new EventBus(stack, 'myEventBus', {
      description: 'myEventBusDescription',
    });

    // THEN
    Template.fromStack(stack).hasResourceProperties('AWS::Events::EventBus', {
      Description: 'myEventBusDescription',
    });
  });

  test('partner event bus', () => {
    // GIVEN
    const stack = new Stack();

    // WHEN
    new EventBus(stack, 'Bus', {
      eventSourceName: 'aws.partner/PartnerName/acct1/repo1',
    });

    // THEN
    Template.fromStack(stack).hasResourceProperties('AWS::Events::EventBus', {
      Name: 'aws.partner/PartnerName/acct1/repo1',
      EventSourceName: 'aws.partner/PartnerName/acct1/repo1',
    });
  });

  test('imported event bus', () => {
    const stack = new Stack();

    const eventBus = new EventBus(stack, 'Bus');

    const importEB = EventBus.fromEventBusArn(stack, 'ImportBus', eventBus.eventBusArn);

    // WHEN
    new CfnResource(stack, 'Res', {
      type: 'Test::Resource',
      properties: {
        EventBusArn1: eventBus.eventBusArn,
        EventBusArn2: importEB.eventBusArn,
      },
    });

    Template.fromStack(stack).hasResourceProperties('Test::Resource', {
      EventBusArn1: { 'Fn::GetAtt': ['BusEA82B648', 'Arn'] },
      EventBusArn2: { 'Fn::GetAtt': ['BusEA82B648', 'Arn'] },
    });
  });

  test('imported event bus from name', () => {
    const stack = new Stack();

    const eventBus = new EventBus(stack, 'Bus', { eventBusName: 'test-bus-to-import-by-name' });

    const importEB = EventBus.fromEventBusName(stack, 'ImportBus', eventBus.eventBusName);

    // WHEN
    expect(stack.resolve(eventBus.eventBusName)).toEqual(stack.resolve(importEB.eventBusName));
  });

  test('same account imported event bus has right resource env', () => {
    const stack = new Stack();

    const eventBus = new EventBus(stack, 'Bus');

    const importEB = EventBus.fromEventBusArn(stack, 'ImportBus', eventBus.eventBusArn);

    // WHEN
    expect(stack.resolve(importEB.env.account)).toEqual({ 'Fn::Select': [4, { 'Fn::Split': [':', { 'Fn::GetAtt': ['BusEA82B648', 'Arn'] }] }] });
    expect(stack.resolve(importEB.env.region)).toEqual({ 'Fn::Select': [3, { 'Fn::Split': [':', { 'Fn::GetAtt': ['BusEA82B648', 'Arn'] }] }] });
  });

  test('cross account imported event bus has right resource env', () => {
    const stack = new Stack();

    const arnParts = {
      resource: 'bus',
      service: 'events',
      account: 'myAccount',
      region: 'us-west-1',
    };

    const arn = Arn.format(arnParts, stack);

    const importEB = EventBus.fromEventBusArn(stack, 'ImportBus', arn);

    // WHEN
    expect(importEB.env.account).toEqual(arnParts.account);
    expect(importEB.env.region).toEqual(arnParts.region);
  });

  test('can get bus name', () => {
    // GIVEN
    const stack = new Stack();
    const bus = new EventBus(stack, 'Bus', {
      eventBusName: 'myEventBus',
    });

    // WHEN
    new CfnResource(stack, 'Res', {
      type: 'Test::Resource',
      properties: {
        EventBusName: bus.eventBusName,
      },
    });

    // THEN
    Template.fromStack(stack).hasResourceProperties('Test::Resource', {
      EventBusName: { Ref: 'BusEA82B648' },
    });
  });

  test('can get bus arn', () => {
    // GIVEN
    const stack = new Stack();
    const bus = new EventBus(stack, 'Bus', {
      eventBusName: 'myEventBus',
    });

    // WHEN
    new CfnResource(stack, 'Res', {
      type: 'Test::Resource',
      properties: {
        EventBusArn: bus.eventBusArn,
      },
    });

    // THEN
    Template.fromStack(stack).hasResourceProperties('Test::Resource', {
      EventBusArn: { 'Fn::GetAtt': ['BusEA82B648', 'Arn'] },
    });
  });

  test('event bus name cannot be default', () => {
    // GIVEN
    const stack = new Stack();

    // WHEN
    const createInvalidBus = () => new EventBus(stack, 'Bus', {
      eventBusName: 'default',
    });

    // THEN
    expect(() => {
      createInvalidBus();
    }).toThrow(/'eventBusName' must not be 'default'/);
  });

  test('event bus name cannot contain slash', () => {
    // GIVEN
    const stack = new Stack();

    // WHEN
    const createInvalidBus = () => new EventBus(stack, 'Bus', {
      eventBusName: 'my/bus',
    });

    // THEN
    expect(() => {
      createInvalidBus();
    }).toThrow(/'eventBusName' must not contain '\/'/);
  });

  test('event bus cannot have name and source name', () => {
    // GIVEN
    const stack = new Stack();

    // WHEN
    const createInvalidBus = () => new EventBus(stack, 'Bus', {
      eventBusName: 'myBus',
      eventSourceName: 'myBus',
    });

    // THEN
    expect(() => {
      createInvalidBus();
    }).toThrow(/'eventBusName' and 'eventSourceName' cannot both be provided/);
  });

  test('event bus name cannot be empty string', () => {
    // GIVEN
    const stack = new Stack();

    // WHEN
    const createInvalidBus = () => new EventBus(stack, 'Bus', {
      eventBusName: '',
    });

    // THEN
    expect(() => {
      createInvalidBus();
    }).toThrow(/'eventBusName' must satisfy: /);
  });

  test('does not throw if eventBusName is a token', () => {
    // GIVEN
    const stack = new Stack();

    // WHEN / THEN
    expect(() => new EventBus(stack, 'EventBus', {
      eventBusName: Aws.STACK_NAME,
    })).not.toThrow();
  });

  test('event bus source name must follow pattern', () => {
    // GIVEN
    const stack = new Stack();

    // WHEN
    const createInvalidBus = () => new EventBus(stack, 'Bus', {
      eventSourceName: 'invalid-partner',
    });

    // THEN
    expect(() => {
      createInvalidBus();
    }).toThrow(/'eventSourceName' must satisfy: \/\^aws/);
  });

  test('does not throw if eventSourceName is a token', () => {
    // GIVEN
    const stack = new Stack();

    // WHEN / THEN
    expect(() => new EventBus(stack, 'EventBus', {
      eventSourceName: Aws.STACK_NAME,
    })).not.toThrow();
  });

  test('event bus source name cannot be empty string', () => {
    // GIVEN
    const stack = new Stack();

    // WHEN
    const createInvalidBus = () => new EventBus(stack, 'Bus', {
      eventSourceName: '',
    });

    // THEN
    expect(() => {
      createInvalidBus();
    }).toThrow(/'eventSourceName' must satisfy: /);
  });

  test('event bus description cannot be too long', () => {
    // GIVEN
    const stack = new Stack();
    const tooLongDescription = 'a'.repeat(513);

    // WHEN / THEN
    expect(() => {
      new EventBus(stack, 'EventBusWithTooLongDescription', {
        description: tooLongDescription,
      });
    }).toThrow('description must be less than or equal to 512 characters, got 513');
  });

  testDeprecated('can grant PutEvents', () => {
    // GIVEN
    const stack = new Stack();
    const role = new iam.Role(stack, 'Role', {
      assumedBy: new iam.ServicePrincipal('lambda.amazonaws.com'),
    });

    // WHEN
    EventBus.grantPutEvents(role);

    // THEN
    Template.fromStack(stack).hasResourceProperties('AWS::IAM::Policy', {
      PolicyDocument: {
        Statement: [
          {
            Action: 'events:PutEvents',
            Effect: 'Allow',
            Resource: '*',
          },
        ],
        Version: '2012-10-17',
      },
      Roles: [
        {
          Ref: 'Role1ABCC5F0',
        },
      ],
    });
  });

  test('can grant PutEvents using grantAllPutEvents', () => {
    // GIVEN
    const stack = new Stack();
    const role = new iam.Role(stack, 'Role', {
      assumedBy: new iam.ServicePrincipal('lambda.amazonaws.com'),
    });

    // WHEN
    EventBus.grantAllPutEvents(role);

    // THEN
    Template.fromStack(stack).hasResourceProperties('AWS::IAM::Policy', {
      PolicyDocument: {
        Statement: [
          {
            Action: 'events:PutEvents',
            Effect: 'Allow',
            Resource: '*',
          },
        ],
        Version: '2012-10-17',
      },
      Roles: [
        {
          Ref: 'Role1ABCC5F0',
        },
      ],
    });
  });

  test('can grant PutEvents to a specific event bus', () => {
    // GIVEN
    const stack = new Stack();
    const role = new iam.Role(stack, 'Role', {
      assumedBy: new iam.ServicePrincipal('lambda.amazonaws.com'),
    });

    const eventBus = new EventBus(stack, 'EventBus');

    // WHEN
    eventBus.grantPutEventsTo(role);

    // THEN
    Template.fromStack(stack).hasResourceProperties('AWS::IAM::Policy', {
      PolicyDocument: {
        Statement: [
          {
            Action: 'events:PutEvents',
            Effect: 'Allow',
            Resource: {
              'Fn::GetAtt': [
                'EventBus7B8748AA',
                'Arn',
              ],
            },
          },
        ],
        Version: '2012-10-17',
      },
      Roles: [
        {
          Ref: 'Role1ABCC5F0',
        },
      ],
    });
  });

  test('can archive events', () => {
    // GIVEN
    const stack = new Stack();

    // WHEN
    const event = new EventBus(stack, 'Bus');

    event.archive('MyArchive', {
      eventPattern: {
        account: [stack.account],
      },
      archiveName: 'MyArchive',
    });

    // THEN
    Template.fromStack(stack).hasResourceProperties('AWS::Events::EventBus', {
      Name: 'Bus',
    });

    Template.fromStack(stack).hasResourceProperties('AWS::Events::Archive', {
      SourceArn: {
        'Fn::GetAtt': [
          'BusEA82B648',
          'Arn',
        ],
      },
      Description: {
        'Fn::Join': [
          '',
          [
            'Event Archive for ',
            {
              Ref: 'BusEA82B648',
            },
            ' Event Bus',
          ],
        ],
      },
      EventPattern: {
        account: [
          {
            Ref: 'AWS::AccountId',
          },
        ],
      },
      RetentionDays: 0,
      ArchiveName: 'MyArchive',
    });
  });

  test('can archive events from an imported EventBus', () => {
    // GIVEN
    const stack = new Stack();

    // WHEN
    const bus = new EventBus(stack, 'Bus');

    const importedBus = EventBus.fromEventBusArn(stack, 'ImportedBus', bus.eventBusArn);

    importedBus.archive('MyArchive', {
      eventPattern: {
        account: [stack.account],
      },
      archiveName: 'MyArchive',
    });

    // THEN
    Template.fromStack(stack).hasResourceProperties('AWS::Events::EventBus', {
      Name: 'Bus',
    });

    Template.fromStack(stack).hasResourceProperties('AWS::Events::Archive', {
      SourceArn: {
        'Fn::GetAtt': [
          'BusEA82B648',
          'Arn',
        ],
      },
      Description: {
        'Fn::Join': [
          '',
          [
            'Event Archive for ',
            {
              'Fn::Select': [
                1,
                {
                  'Fn::Split': [
                    '/',
                    {
                      'Fn::Select': [
                        5,
                        {
                          'Fn::Split': [
                            ':',
                            {
                              'Fn::GetAtt': [
                                'BusEA82B648',
                                'Arn',
                              ],
                            },
                          ],
                        },
                      ],
                    },
                  ],
                },
              ],
            },
            ' Event Bus',
          ],
        ],
      },
      EventPattern: {
        account: [
          {
            Ref: 'AWS::AccountId',
          },
        ],
      },
      RetentionDays: 0,
      ArchiveName: 'MyArchive',
    });
  });

  test('cross account event bus uses generated physical name', () => {
    // GIVEN
    const app = new App();
    const stack1 = new Stack(app, 'Stack1', {
      env: {
        account: '11111111111',
        region: 'us-east-1',
      },
    });
    const stack2 = new Stack(app, 'Stack2', {
      env: {
        account: '22222222222',
        region: 'us-east-1',
      },
    });

    // WHEN
    const bus1 = new EventBus(stack1, 'Bus', {
      eventBusName: PhysicalName.GENERATE_IF_NEEDED,
    });

    new CfnOutput(stack2, 'BusName', { value: bus1.eventBusName });

    // THEN
    Template.fromStack(stack1).hasResourceProperties('AWS::Events::EventBus', {
      Name: 'stack1stack1busca19bdf8ab2e51b62a5a',
    });
  });

  test('can add one event bus policy', () => {
    // GIVEN
    const app = new App();
    const stack = new Stack(app, 'Stack');
    const bus = new EventBus(stack, 'Bus');

    // WHEN
    bus.addToResourcePolicy(new iam.PolicyStatement({
      effect: iam.Effect.ALLOW,
      principals: [new iam.AccountPrincipal('111111111111111')],
      actions: ['events:PutEvents'],
      sid: '123',
      resources: [bus.eventBusArn],
    }));

    // THEN
    Template.fromStack(stack).hasResourceProperties('AWS::Events::EventBusPolicy', {
      StatementId: 'cdk-123',
      EventBusName: {
        Ref: 'BusEA82B648',
      },
      Statement: {
        Action: 'events:PutEvents',
        Effect: 'Allow',
        Principal: {
          AWS: {
            'Fn::Join': [
              '',
              [
                'arn:',
                {
                  Ref: 'AWS::Partition',
                },
                ':iam::111111111111111:root',
              ],
            ],
          },
        },
        Sid: 'cdk-123',
        Resource: {
          'Fn::GetAtt': [
            'BusEA82B648',
            'Arn',
          ],
        },
      },
    });
  });

  test('can add more than one event bus policy', () => {
    // GIVEN
    const app = new App();
    const stack = new Stack(app, 'Stack');
    const bus = new EventBus(stack, 'Bus');

    const statement1 = new iam.PolicyStatement({
      effect: iam.Effect.ALLOW,
      principals: [new iam.ArnPrincipal('arn')],
      actions: ['events:PutEvents'],
      sid: 'statement1',
      resources: [bus.eventBusArn],
    });

    const statement2 = new iam.PolicyStatement({
      effect: iam.Effect.ALLOW,
      principals: [new iam.ArnPrincipal('arn')],
      actions: ['events:DeleteRule'],
      sid: 'statement2',
      resources: [bus.eventBusArn],
    });

    // WHEN
    const add1 = bus.addToResourcePolicy(statement1);
    const add2 = bus.addToResourcePolicy(statement2);

    // THEN
    expect(add1.statementAdded).toBe(true);
    expect(add2.statementAdded).toBe(true);
    Template.fromStack(stack).resourceCountIs('AWS::Events::EventBusPolicy', 2);
  });

  test('Event Bus policy statements must have a sid', () => {
    // GIVEN
    const app = new App();
    const stack = new Stack(app, 'Stack');
    const bus = new EventBus(stack, 'Bus');

    // THEN
    expect(() => bus.addToResourcePolicy(new iam.PolicyStatement({
      effect: iam.Effect.ALLOW,
      principals: [new iam.ArnPrincipal('arn')],
      actions: ['events:PutEvents'],
    }))).toThrow('Event Bus policy statements must have a sid');
  });

  test('set dead letter queue', () => {
    const app = new App();
    const stack = new Stack(app, 'Stack');
    const dlq = new sqs.Queue(stack, 'DLQ');
    new EventBus(stack, 'Bus', {
      deadLetterQueue: dlq,
    });

    Template.fromStack(stack).hasResourceProperties('AWS::Events::EventBus', {
      DeadLetterConfig: {
        Arn: {
          'Fn::GetAtt': ['DLQ581697C4', 'Arn'],
        },
      },
    });
  });
  test('Event Bus with a customer managed key', () => {
    // GIVEN
    const app = new App();
    const stack = new Stack(app, 'Stack');
    const key = new kms.Key(stack, 'Key');

    // WHEN
    const eventBus = new EventBus(stack, 'Bus', {
      kmsKey: key,
    });

    // THEN
    Template.fromStack(stack).hasResourceProperties('AWS::Events::EventBus', {
      KmsKeyIdentifier: stack.resolve(key.keyArn),
    });

    Template.fromStack(stack).hasResourceProperties('AWS::KMS::Key', {
      KeyPolicy: {
        Statement: [
          {
            Action: 'kms:*',
            Effect: 'Allow',
            Principal: {
              AWS: {
                'Fn::Join': [
                  '',
                  [
                    'arn:',
                    {
                      Ref: 'AWS::Partition',
                    },
                    ':iam::',
                    {
                      Ref: 'AWS::AccountId',
                    },
                    ':root',
                  ],
                ],
              },
            },
            Resource: '*',
          },
          {
            Action: [
              'kms:Decrypt',
              'kms:GenerateDataKey',
              'kms:DescribeKey',
            ],
            Condition: {
              StringEquals: {
                'aws:SourceAccount': {
                  Ref: 'AWS::AccountId',
                },
                'aws:SourceArn': {
                  'Fn::Join': [
                    '',
                    [
                      'arn:',
                      {
                        Ref: 'AWS::Partition',
                      },
                      ':events:',
                      {
                        Ref: 'AWS::Region',
                      },
                      ':',
                      {
                        Ref: 'AWS::AccountId',
                      },
                      ':event-bus/StackBusAA0A1E4B',
                    ],
                  ],
                },
                'kms:EncryptionContext:aws:events:event-bus:arn': {
                  'Fn::Join': [
                    '',
                    [
                      'arn:',
                      {
                        Ref: 'AWS::Partition',
                      },
                      ':events:',
                      {
                        Ref: 'AWS::Region',
                      },
                      ':',
                      {
                        Ref: 'AWS::AccountId',
                      },
                      ':event-bus/StackBusAA0A1E4B',
                    ],
                  ],
                },
              },
            },
            Effect: 'Allow',
            Principal: {
              Service: 'events.amazonaws.com',
            },
            Resource: '*',
          },
        ],
        Version: '2012-10-17',
      },
    });
  });

});

```

**AWS CDK Tested Construct Type Declarations:**
Refer to the following Reference declarations used by the AWSCDK constructs:
```typescript
// event-bus.d.ts
import { Construct } from 'constructs';
import { Archive, BaseArchiveProps } from './archive';
import * as iam from '../../aws-iam';
import * as kms from '../../aws-kms';
import * as sqs from '../../aws-sqs';
import { IResource, Resource } from '../../core';
/**
 * Interface which all EventBus based classes MUST implement
 */
export interface IEventBus extends IResource {
    /**
     * The physical ID of this event bus resource
     *
     * @attribute
     * @link https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-events-eventbus.html#cfn-events-eventbus-name
     */
    readonly eventBusName: string;
    /**
     * The ARN of this event bus resource
     *
     * @attribute
     * @link https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-events-eventbus.html#Arn-fn::getatt
     */
    readonly eventBusArn: string;
    /**
     * The JSON policy of this event bus resource
     *
     * @attribute
     * @link https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-events-eventbus.html#Policy-fn::getatt
     */
    readonly eventBusPolicy: string;
    /**
     * The partner event source to associate with this event bus resource
     *
     * @link https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-events-eventbus.html#cfn-events-eventbus-eventsourcename
     */
    readonly eventSourceName?: string;
    /**
     * Create an EventBridge archive to send events to.
     * When you create an archive, incoming events might not immediately start being sent to the archive.
     * Allow a short period of time for changes to take effect.
     *
     * @param props Properties of the archive
     */
    archive(id: string, props: BaseArchiveProps): Archive;
    /**
     * Grants an IAM Principal to send custom events to the eventBus
     * so that they can be matched to rules.
     *
     * @param grantee The principal (no-op if undefined)
     */
    grantPutEventsTo(grantee: iam.IGrantable): iam.Grant;
}
/**
 * Properties to define an event bus
 */
export interface EventBusProps {
    /**
     * The name of the event bus you are creating
     * Note: If 'eventSourceName' is passed in, you cannot set this
     *
     * @link https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-events-eventbus.html#cfn-events-eventbus-name
     * @default - automatically generated name
     */
    readonly eventBusName?: string;
    /**
     * The partner event source to associate with this event bus resource
     * Note: If 'eventBusName' is passed in, you cannot set this
     *
     * @link https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-events-eventbus.html#cfn-events-eventbus-eventsourcename
     * @default - no partner event source
     */
    readonly eventSourceName?: string;
    /**
     * Dead-letter queue for the event bus
     *
     * @see https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-rule-event-delivery.html#eb-rule-dlq
     *
     * @default - no dead-letter queue
     */
    readonly deadLetterQueue?: sqs.IQueue;
    /**
     * The event bus description.
     *
     * The description can be up to 512 characters long.
     *
     * @see http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-events-eventbus.html#cfn-events-eventbus-description
     *
     * @default - no description
     */
    readonly description?: string;
    /**
     * The customer managed key that encrypt events on this event bus.
     *
     * @default - Use an AWS managed key
     */
    readonly kmsKey?: kms.IKey;
}
/**
 * Interface with properties necessary to import a reusable EventBus
 */
export interface EventBusAttributes {
    /**
     * The physical ID of this event bus resource
     *
     * @link https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-events-eventbus.html#cfn-events-eventbus-name
     */
    readonly eventBusName: string;
    /**
     * The ARN of this event bus resource
     *
     * @link https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-events-eventbus.html#Arn-fn::getatt
     */
    readonly eventBusArn: string;
    /**
     * The JSON policy of this event bus resource
     *
     * @link https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-events-eventbus.html#Policy-fn::getatt
     */
    readonly eventBusPolicy: string;
    /**
     * The partner event source to associate with this event bus resource
     *
     * @link https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-events-eventbus.html#cfn-events-eventbus-eventsourcename
     * @default - no partner event source
     */
    readonly eventSourceName?: string;
}
declare abstract class EventBusBase extends Resource implements IEventBus {
    /**
     * The physical ID of this event bus resource
     */
    abstract readonly eventBusName: string;
    /**
     * The ARN of the event bus, such as:
     * arn:aws:events:us-east-2:123456789012:event-bus/aws.partner/PartnerName/acct1/repo1.
     */
    abstract readonly eventBusArn: string;
    /**
     * The policy for the event bus in JSON form.
     */
    abstract readonly eventBusPolicy: string;
    /**
     * The name of the partner event source
     */
    abstract readonly eventSourceName?: string;
    archive(id: string, props: BaseArchiveProps): Archive;
    grantPutEventsTo(grantee: iam.IGrantable): iam.Grant;
}
/**
 * Define an EventBridge EventBus
 *
 * @resource AWS::Events::EventBus
 */
export declare class EventBus extends EventBusBase {
    /**
     * Import an existing event bus resource
     * @param scope Parent construct
     * @param id Construct ID
     * @param eventBusArn ARN of imported event bus
     */
    static fromEventBusArn(scope: Construct, id: string, eventBusArn: string): IEventBus;
    /**
     * Import an existing event bus resource
     * @param scope Parent construct
     * @param id Construct ID
     * @param eventBusName Name of imported event bus
     */
    static fromEventBusName(scope: Construct, id: string, eventBusName: string): IEventBus;
    /**
     * Import an existing event bus resource
     * @param scope Parent construct
     * @param id Construct ID
     * @param attrs Imported event bus properties
     */
    static fromEventBusAttributes(scope: Construct, id: string, attrs: EventBusAttributes): IEventBus;
    /**
     * Permits an IAM Principal to send custom events to EventBridge
     * so that they can be matched to rules.
     *
     * @param grantee The principal (no-op if undefined)
     */
    static grantAllPutEvents(grantee: iam.IGrantable): iam.Grant;
    private static eventBusProps;
    /**
     * The physical ID of this event bus resource
     */
    readonly eventBusName: string;
    /**
     * The ARN of the event bus, such as:
     * arn:aws:events:us-east-2:123456789012:event-bus/aws.partner/PartnerName/acct1/repo1.
     */
    readonly eventBusArn: string;
    /**
     * The policy for the event bus in JSON form.
     */
    readonly eventBusPolicy: string;
    /**
     * The name of the partner event source
     */
    readonly eventSourceName?: string;
    constructor(scope: Construct, id: string, props?: EventBusProps);
    /**
     * Adds a statement to the IAM resource policy associated with this event bus.
     */
    addToResourcePolicy(statement: iam.PolicyStatement): iam.AddToResourcePolicyResult;
}
/**
 * Properties to associate Event Buses with a policy
 */
export interface EventBusPolicyProps {
    /**
     * The event bus to which the policy applies
     */
    readonly eventBus: IEventBus;
    /**
     * An IAM Policy Statement to apply to the Event Bus
     */
    readonly statement: iam.PolicyStatement;
    /**
     * An identifier string for the external account that
     * you are granting permissions to.
     */
    readonly statementId: string;
}
/**
 * The policy for an Event Bus
 *
 * Policies define the operations that are allowed on this resource.
 *
 * You almost never need to define this construct directly.
 *
 * All AWS resources that support resource policies have a method called
 * `addToResourcePolicy()`, which will automatically create a new resource
 * policy if one doesn't exist yet, otherwise it will add to the existing
 * policy.
 *
 * Prefer to use `addToResourcePolicy()` instead.
 */
export declare class EventBusPolicy extends Resource {
    constructor(scope: Construct, id: string, props: EventBusPolicyProps);
}
export {};

```

**Conversion**:
```typescript
import {
  cloudwatchEventBus,
  cloudwatchEventArchive,
  cloudwatchEventBusPolicy,
  dataAwsIamPolicyDocument,
  kmsKey,
  iamRolePolicy,
} from "@cdktf/provider-aws";
import {
  Lazy,
  TerraformMetaArguments,
  TerraformOutput,
  TerraformResource,
  Testing,
} from "cdktf";
import "cdktf/lib/testing/adapters/jest";
import { Construct } from "constructs";
import { AwsStack, Arn } from "../../../src/aws";
import * as kms from "../../../src/aws/encryption";
import * as iam from "../../../src/aws/iam";
import { EventBus } from "../../../src/aws/notify/event-bus";
import { Template } from "../../assertions";

const environmentName = "Test";
const gridUUID = "123e4567-e89b-12d3";
const providerConfig = { region: "us-east-1" };
const gridBackendConfig = {
  address: "http://localhost:3000",
};

describe("event bus", () => {
  let stack: AwsStack;

  beforeEach(() => {
    const app = Testing.app();
    stack = new AwsStack(app, "TestStack", {
      environmentName,
      gridUUID,
      providerConfig,
      gridBackendConfig,
    });
  });

  test("default event bus", () => {
    // GIVEN

    // WHEN
    new EventBus(stack, "Bus");

    // THEN
    Template.synth(stack).toHaveResourceWithProperties(
      cloudwatchEventBus.CloudwatchEventBus,
      {
        // name: "Bus", // TODO: BUG - This should be the name of the event bus
        name: "TestStackBus54CCAD7F",
      }
    );
  });

  test("default event bus with empty props object", () => {
    // GIVEN

    // WHEN
    new EventBus(stack, "Bus", {});

    // THEN
    Template.synth(stack).toHaveResourceWithProperties(
      cloudwatchEventBus.CloudwatchEventBus,
      {
        // name: "Bus", // TODO: BUG - This should be the name of the event bus
        name: "TestStackBus54CCAD7F",
      }
    );
  });

  test("named event bus", () => {
    // GIVEN

    // WHEN
    new EventBus(stack, "Bus", {
      eventBusName: "myEventBus",
    });

    // THEN
    Template.synth(stack).toHaveResourceWithProperties(
      cloudwatchEventBus.CloudwatchEventBus,
      {
        name: "myEventBus",
      }
    );
  });

  // // TODO: Event Bus Description is not supported by terraform-provider-aws
  // test("event bus with description", () => {
  //   // GIVEN

  //   // WHEN
  //   new EventBus(stack, "myEventBus", {
  //     description: "myEventBusDescription",
  //   });

  //   // THEN
  //   Template.synth(stack).toHaveResourceWithProperties(
  //     cloudwatchEventBus.CloudwatchEventBus,
  //     {
  //       description: "myEventBusDescription",
  //     },
  //   );
  // });

  test("partner event bus", () => {
    // GIVEN

    // WHEN
    new EventBus(stack, "Bus", {
      eventSourceName: "aws.partner/PartnerName/acct1/repo1",
    });

    // THEN
    Template.synth(stack).toHaveResourceWithProperties(
      cloudwatchEventBus.CloudwatchEventBus,
      {
        name: "aws.partner/PartnerName/acct1/repo1",
        event_source_name: "aws.partner/PartnerName/acct1/repo1",
      }
    );
  });

  test("imported event bus", () => {
    const eventBus = new EventBus(stack, "Bus");

    const importEB = EventBus.fromEventBusArn(
      stack,
      "ImportBus",
      eventBus.eventBusArn
    );

    // WHEN
    new TestResource(stack, "Res", {
      properties: {
        EventBusArn1: eventBus.eventBusArn,
        EventBusArn2: importEB.eventBusArn,
      },
    });

    Template.synth(stack).toHaveResourceWithProperties(TestResource, {
      EventBusArn1: "${aws_cloudwatch_event_bus.Bus_EA82B648.arn}",
      EventBusArn2: "${aws_cloudwatch_event_bus.Bus_EA82B648.arn}",
    });
  });

  test("imported event bus from name", () => {
    const eventBus = new EventBus(stack, "Bus", {
      eventBusName: "test-bus-to-import-by-name",
    });

    const importEB = EventBus.fromEventBusName(
      stack,
      "ImportBus",
      eventBus.eventBusName
    );

    // WHEN
    expect(stack.resolve(eventBus.eventBusName)).toEqual(
      stack.resolve(importEB.eventBusName)
    );
  });

  test("same account imported event bus has right resource env", () => {
    const eventBus = new EventBus(stack, "Bus");

    const importEB = EventBus.fromEventBusArn(
      stack,
      "ImportBus",
      eventBus.eventBusArn
    );

    // WHEN
    expect(stack.resolve(importEB.env.account)).toEqual(
      '${element(split(":", aws_cloudwatch_event_bus.Bus_EA82B648.arn), 4)}'
    );
    expect(stack.resolve(importEB.env.region)).toEqual(
      '${element(split(":", aws_cloudwatch_event_bus.Bus_EA82B648.arn), 3)}'
    );
  });

  test("cross account imported event bus has right resource env", () => {
    const arnParts = {
      resource: "bus",
      service: "events",
      account: "myAccount",
      region: "us-west-1",
    };

    const arn = Arn.format(arnParts, stack);

    const importEB = EventBus.fromEventBusArn(stack, "ImportBus", arn);

    // WHEN
    expect(importEB.env.account).toEqual(arnParts.account);
    expect(importEB.env.region).toEqual(arnParts.region);
  });

  test("can get bus name", () => {
    // GIVEN
    const bus = new EventBus(stack, "Bus", {
      eventBusName: "myEventBus",
    });

    // WHEN
    new TestResource(stack, "Res", {
      properties: {
        EventBusName: bus.eventBusName,
      },
    });

    // THEN
    Template.synth(stack).toHaveResourceWithProperties(TestResource, {
      EventBusName: "${aws_cloudwatch_event_bus.Bus_EA82B648.name}",
    });
  });

  test("can get bus arn", () => {
    // GIVEN
    const bus = new EventBus(stack, "Bus", {
      eventBusName: "myEventBus",
    });

    // WHEN
    new TestResource(stack, "Res", {
      properties: {
        EventBusArn: bus.eventBusArn,
      },
    });

    // THEN
    Template.synth(stack).toHaveResourceWithProperties(TestResource, {
      EventBusArn: "${aws_cloudwatch_event_bus.Bus_EA82B648.arn}",
    });
  });

  test("event bus name cannot be default", () => {
    // GIVEN

    // WHEN
    const createInvalidBus = () =>
      new EventBus(stack, "Bus", {
        eventBusName: "default",
      });

    // THEN
    expect(() => {
      createInvalidBus();
    }).toThrow(/'eventBusName' must not be 'default'/);
  });

  test("event bus name cannot contain slash", () => {
    // GIVEN

    // WHEN
    const createInvalidBus = () =>
      new EventBus(stack, "Bus", {
        eventBusName: "my/bus",
      });

    // THEN
    expect(() => {
      createInvalidBus();
    }).toThrow(/'eventBusName' must not contain '\/'/);
  });

  test("event bus cannot have name and source name", () => {
    // GIVEN

    // WHEN
    const createInvalidBus = () =>
      new EventBus(stack, "Bus", {
        eventBusName: "myBus",
        eventSourceName: "myBus",
      });

    // THEN
    expect(() => {
      createInvalidBus();
    }).toThrow(/'eventBusName' and 'eventSourceName' cannot both be provided/);
  });

  test("event bus name cannot be empty string", () => {
    // GIVEN

    // WHEN
    const createInvalidBus = () =>
      new EventBus(stack, "Bus", {
        eventBusName: "",
      });

    // THEN
    expect(() => {
      createInvalidBus();
    }).toThrow(/'eventBusName' must satisfy: /);
  });

  test("does not throw if eventBusName is a token", () => {
    // GIVEN

    // WHEN / THEN
    expect(
      () =>
        new EventBus(stack, "EventBus", {
          eventBusName: Lazy.stringValue({
            produce: () => "Example",
          }),
        })
    ).not.toThrow();
  });

  test("event bus source name must follow pattern", () => {
    // GIVEN

    // WHEN
    const createInvalidBus = () =>
      new EventBus(stack, "Bus", {
        eventSourceName: "invalid-partner",
      });

    // THEN
    expect(() => {
      createInvalidBus();
    }).toThrow(/'eventSourceName' must satisfy: \/\^aws/);
  });

  test("does not throw if eventSourceName is a token", () => {
    // GIVEN

    // WHEN / THEN
    expect(
      () =>
        new EventBus(stack, "EventBus", {
          eventSourceName: Lazy.stringValue({
            produce: () => "Example",
          }),
        })
    ).not.toThrow();
  });

  test("event bus source name cannot be empty string", () => {
    // GIVEN

    // WHEN
    const createInvalidBus = () =>
      new EventBus(stack, "Bus", {
        eventSourceName: "",
      });

    // THEN
    expect(() => {
      createInvalidBus();
    }).toThrow(/'eventSourceName' must satisfy: /);
  });

  // TODO: Event Bus Description is not supported by terraform-provider-aws
  // test("event bus description cannot be too long", () => {
  //   // GIVEN
  //   const tooLongDescription = "a".repeat(513);

  //   // WHEN / THEN
  //   expect(() => {
  //     new EventBus(stack, "EventBusWithTooLongDescription", {
  //       description: tooLongDescription,
  //     });
  //   }).toThrow(
  //     "description must be less than or equal to 512 characters, got 513",
  //   );
  // });

  // DEPRECATED
  test("can grant PutEvents", () => {
    // GIVEN
    const role = new iam.Role(stack, "Role", {
      assumedBy: new iam.ServicePrincipal("lambda.amazonaws.com"),
    });

    // WHEN
    EventBus.grantPutEvents(role);

    // THEN
    Template.synth(stack).toHaveDataSourceWithProperties(
      dataAwsIamPolicyDocument.DataAwsIamPolicyDocument,
      {
        statement: [
          {
            actions: ["events:PutEvents"],
            effect: "Allow",
            resources: ["*"],
          },
        ],
      }
    );
  });

  test("can grant PutEvents using grantAllPutEvents", () => {
    // GIVEN
    const role = new iam.Role(stack, "Role", {
      assumedBy: new iam.ServicePrincipal("lambda.amazonaws.com"),
    });

    // WHEN
    EventBus.grantAllPutEvents(role);

    // THEN
    Template.synth(stack).toHaveDataSourceWithProperties(
      dataAwsIamPolicyDocument.DataAwsIamPolicyDocument,
      {
        statement: [
          {
            actions: ["events:PutEvents"],
            effect: "Allow",
            resources: ["*"],
          },
        ],
      }
    );
  });

  test("can grant PutEvents to a specific event bus", () => {
    // GIVEN
    const role = new iam.Role(stack, "Role", {
      assumedBy: new iam.ServicePrincipal("lambda.amazonaws.com"),
    });

    const eventBus = new EventBus(stack, "EventBus");

    // WHEN
    eventBus.grantPutEventsTo(role);

    // THEN
    const t = new Template(stack);
    t.expect.toHaveDataSourceWithProperties(
      dataAwsIamPolicyDocument.DataAwsIamPolicyDocument,
      {
        statement: [
          {
            actions: ["events:PutEvents"],
            effect: "Allow",
            resources: [stack.resolve(eventBus.eventBusArn)],
          },
        ],
      }
    );
    t.expect.toHaveResourceWithProperties(iamRolePolicy.IamRolePolicy, {
      name: "TestStackRoleDefaultPolicyC86B8D55",
      policy:
        "${data.aws_iam_policy_document.Role_DefaultPolicy_2E5E5E0B.json}",
      role: stack.resolve(role.roleName),
    });
  });

  test("can archive events", () => {
    // GIVEN

    // WHEN
    const event = new EventBus(stack, "Bus");

    event.archive("MyArchive", {
      eventPattern: {
        account: [stack.account],
      },
      archiveName: "MyArchive",
    });

    // THEN
    Template.synth(stack).toHaveResourceWithProperties(
      cloudwatchEventBus.CloudwatchEventBus,
      {
        // name: "Bus", // TODO: BUG - This should be the name of the event bus
        name: "TestStackBus54CCAD7F",
      }
    );

    Template.synth(stack).toHaveResourceWithProperties(
      cloudwatchEventArchive.CloudwatchEventArchive,
      {
        description:
          "Event Archive for ${aws_cloudwatch_event_bus.Bus_EA82B648.name} Event Bus",
        event_pattern: {
          account: ["${data.aws_caller_identity.CallerIdentity.account_id}"],
        },
        event_source_arn: stack.resolve(event.eventBusArn), // "${aws_cloudwatch_event_bus.Bus_EA82B648.arn}",
        name: "MyArchive",
        retention_days: 0,
      }
    );
  });

  test("can archive events from an imported EventBus", () => {
    // GIVEN

    // WHEN
    const bus = new EventBus(stack, "Bus");

    const importedBus = EventBus.fromEventBusArn(
      stack,
      "ImportedBus",
      bus.eventBusArn
    );

    importedBus.archive("MyArchive", {
      eventPattern: {
        account: [stack.account],
      },
      archiveName: "MyArchive",
    });

    // THEN
    const t = new Template(stack);

    t.expect.toHaveResourceWithProperties(
      cloudwatchEventBus.CloudwatchEventBus,
      {
        // name: "Bus", // TODO: BUG - This should be the name of the event bus
        name: "TestStackBus54CCAD7F",
      }
    );

    t.expect.toHaveResourceWithProperties(
      cloudwatchEventArchive.CloudwatchEventArchive,
      {
        description:
          'Event Archive for ${element(split("/", element(split(":", aws_cloudwatch_event_bus.Bus_EA82B648.arn), 5)), 1)} Event Bus',
        event_pattern: {
          account: ["${data.aws_caller_identity.CallerIdentity.account_id}"],
        },
        event_source_arn: stack.resolve(bus.eventBusArn),
        name: "MyArchive",
        retention_days: 0,
      }
    );
  });

  test("cross account event bus uses generated physical name", () => {
    // GIVEN
    // env: {
    //   account: "11111111111",
    //   region: "us-east-1",
    // },
    const stack1 = new AwsStack(Testing.app(), "Stack1", {
      environmentName,
      gridUUID,
      providerConfig,
      gridBackendConfig,
    });
    // env: {
    //   account: "22222222222",
    //   region: "us-east-1",
    // },
    const stack2 = new AwsStack(Testing.app(), "Stack2", {
      environmentName,
      gridUUID,
      providerConfig,
      gridBackendConfig,
    });

    // WHEN
    const bus1 = new EventBus(stack1, "Bus", {
      eventBusName: Lazy.stringValue({
        produce: () => "stack1bus",
      }), // PhysicalName.GENERATE_IF_NEEDED,
    });

    new TerraformOutput(stack2, "BusName", { value: bus1.eventBusName });

    // THEN
    Template.synth(stack1).toHaveResourceWithProperties(
      cloudwatchEventBus.CloudwatchEventBus,
      {
        name: "stack1bus",
        // Name: "stack1stack1busca19bdf8ab2e51b62a5a",
      }
    );
  });

  test("can add one event bus policy", () => {
    // GIVEN
    const bus = new EventBus(stack, "Bus");

    // WHEN
    bus.addToResourcePolicy(
      new iam.PolicyStatement({
        effect: iam.Effect.ALLOW,
        principals: [new iam.AccountPrincipal("111111111111111")],
        actions: ["events:PutEvents"],
        sid: "123",
        resources: [bus.eventBusArn],
      })
    );

    // THEN
    const t = new Template(stack);
    t.expect.toHaveResourceWithProperties(
      cloudwatchEventBusPolicy.CloudwatchEventBusPolicy,
      {
        event_bus_name: "${aws_cloudwatch_event_bus.Bus_EA82B648.name}",
        policy:
          "${data.aws_iam_policy_document.Bus_Policy_Document_ABBD772C.json}",
      }
    );
    t.expect.toHaveDataSourceWithProperties(
      dataAwsIamPolicyDocument.DataAwsIamPolicyDocument,
      {
        statement: [
          {
            sid: "123",
            actions: ["events:PutEvents"],
            effect: "Allow",
            principals: [
              {
                identifiers: [
                  "arn:${data.aws_partition.Partitition.partition}:iam::111111111111111:root",
                ],
                type: "AWS",
              },
            ],
            resources: [stack.resolve(bus.eventBusArn)],
          },
        ],
      }
    );
  });

  // TODO: TerraConstructs aggregates all statements in a single policy document...
  test.skip("can add more than one event bus policy", () => {
    // GIVEN
    const bus = new EventBus(stack, "Bus");

    const statement1 = new iam.PolicyStatement({
      effect: iam.Effect.ALLOW,
      principals: [new iam.ArnPrincipal("arn")],
      actions: ["events:PutEvents"],
      sid: "statement1",
      resources: [bus.eventBusArn],
    });

    const statement2 = new iam.PolicyStatement({
      effect: iam.Effect.ALLOW,
      principals: [new iam.ArnPrincipal("arn")],
      actions: ["events:DeleteRule"],
      sid: "statement2",
      resources: [bus.eventBusArn],
    });

    // WHEN
    const add1 = bus.addToResourcePolicy(statement1);
    const add2 = bus.addToResourcePolicy(statement2);

    // THEN
    expect(add1.statementAdded).toBe(true);
    expect(add2.statementAdded).toBe(true);
    const t = new Template(stack);
    t.resourceCountIs(cloudwatchEventBusPolicy.CloudwatchEventBusPolicy, 2);
  });

  // TODO: TerraConstructs does not error when sid is not provided
  test.skip("Event Bus policy statements must have a sid", () => {
    // GIVEN
    const bus = new EventBus(stack, "Bus");

    // THEN
    expect(() =>
      bus.addToResourcePolicy(
        new iam.PolicyStatement({
          effect: iam.Effect.ALLOW,
          principals: [new iam.ArnPrincipal("arn")],
          actions: ["events:PutEvents"],
        })
      )
    ).toThrow("Event Bus policy statements must have a sid");
  });

  // TODO: Event Bus DQL is not supported by terraform-provider-aws
  // test("set dead letter queue", () => {
  //   const dlq = new sqs.Queue(stack, "DLQ");
  //   new EventBus(stack, "Bus", {
  //     deadLetterQueue: dlq,
  //   });

  //   Template.synth(stack).toHaveResourceWithProperties(
  //     cloudwatchEventBus.CloudwatchEventBus,
  //     {
  //       DeadLetterConfig: {
  //         Arn: {
  //           "Fn::GetAtt": ["DLQ581697C4", "Arn"],
  //         },
  //       },
  //     },
  //   );
  // });

  test("Event Bus with a customer managed key", () => {
    // GIVEN
    const key = new kms.Key(stack, "Key");

    // WHEN
    const eventBus = new EventBus(stack, "Bus", {
      kmsKey: key,
    });

    // THEN
    const t = new Template(stack);
    t.expect.toHaveResourceWithProperties(
      cloudwatchEventBus.CloudwatchEventBus,
      {
        kms_key_identifier: stack.resolve(key.keyArn),
      }
    );

    t.expect.toHaveResourceWithProperties(kmsKey.KmsKey, {
      policy: "${data.aws_iam_policy_document.Key_Policy_48E51E45.json}",
    });
    t.expect.toHaveDataSourceWithProperties(
      dataAwsIamPolicyDocument.DataAwsIamPolicyDocument,
      {
        statement: [
          {
            actions: ["kms:*"],
            effect: "Allow",
            principals: [
              {
                identifiers: [
                  "arn:${data.aws_partition.Partitition.partition}:iam::${data.aws_caller_identity.CallerIdentity.account_id}:root",
                ],
                type: "AWS",
              },
            ],
            resources: ["*"],
          },
          {
            actions: ["kms:Decrypt", "kms:GenerateDataKey", "kms:DescribeKey"],
            condition: [
              {
                test: "StringEquals",
                values: [
                  "${data.aws_caller_identity.CallerIdentity.account_id}",
                ],
                variable: "aws:SourceAccount",
              },
              {
                test: "StringEquals",
                values: [
                  "arn:${data.aws_partition.Partitition.partition}:events:us-east-1:${data.aws_caller_identity.CallerIdentity.account_id}:event-bus/TestStackBus54CCAD7F",
                ],
                variable: "aws:SourceArn",
              },
              {
                test: "StringEquals",
                values: [
                  "arn:${data.aws_partition.Partitition.partition}:events:us-east-1:${data.aws_caller_identity.CallerIdentity.account_id}:event-bus/TestStackBus54CCAD7F",
                ],
                variable: "kms:EncryptionContext:aws:events:event-bus:arn",
              },
            ],
            effect: "Allow",
            principals: [
              {
                identifiers: [
                  "${data.aws_service_principal.aws_svcp_default_region_events.name}",
                ],
                type: "Service",
              },
            ],
            resources: ["*"],
          },
        ],
      }
    );
  });
});

export enum TestProviderMetadata {
  TYPE = "test",
}
export interface TestResourceConfig extends TerraformMetaArguments {
  readonly properties?: { [name: string]: any };
}
export class TestResource extends TerraformResource {
  public static readonly tfResourceType: string = "test_resource";

  /**
   * AWS CloudFormation resource properties.
   *
   * This object is returned via cfnProperties
   * @internal
   */
  protected readonly _properties: any;
  constructor(scope: Construct, id: string, config: TestResourceConfig) {
    super(scope, id, {
      terraformResourceType: "test_resource",
      terraformGeneratorMetadata: {
        providerName: TestProviderMetadata.TYPE,
        providerVersionConstraint: "~> 2.0",
      },
      provider: config.provider,
      dependsOn: config.dependsOn,
      count: config.count,
      lifecycle: config.lifecycle,
      provisioners: config.provisioners,
      forEach: config.forEach,
    });
    this._properties = config.properties || {};
  }

  public get names(): string[] {
    return this.getListAttribute("names");
  }

  protected synthesizeAttributes(): { [name: string]: any } {
    return this._properties;
  }
}

```

**Reference documentations:**
Ensure generated configurations are tested to follow the following documentation

------------------------
// cloudwatch_event_bus.html.markdown
---
subcategory: "EventBridge"
layout: "aws"
page_title: "AWS: aws_cloudwatch_event_bus"
description: |-
  Provides an EventBridge event bus resource.
---

### Resource: aws_cloudwatch_event_bus

Provides an EventBridge event bus resource.

~> **Note:** EventBridge was formerly known as CloudWatch Events. The functionality is identical.

#### Example Usage

```terraform
resource "aws_cloudwatch_event_bus" "messenger" {
  name = "chat-messages"
}
```

```terraform
data "aws_cloudwatch_event_source" "examplepartner" {
  name_prefix = "aws.partner/examplepartner.com"
}

resource "aws_cloudwatch_event_bus" "examplepartner" {
  name              = data.aws_cloudwatch_event_source.examplepartner.name
  description       = "Event bus for example partner events"
  event_source_name = data.aws_cloudwatch_event_source.examplepartner.name
}
```

#### Argument Reference

This resource supports the following arguments:

The following arguments are required:

* `name` - (Required) Name of the new event bus. The names of custom event buses can't contain the / character. To create a partner event bus, ensure that the `name` matches the `event_source_name`.

The following arguments are optional:

* `description` - (Optional) Event bus description.
* `event_source_name` - (Optional) Partner event source that the new event bus will be matched with. Must match `name`.
* `kms_key_identifier` - (Optional) Identifier of the AWS KMS customer managed key for EventBridge to use, if you choose to use a customer managed key to encrypt events on this event bus. The identifier can be the key Amazon Resource Name (ARN), KeyId, key alias, or key alias ARN.
* `tags` - (Optional) Map of tags assigned to the resource. If configured with a provider [`default_tags` configuration block](/docs/providers/aws/index.html#default_tags-configuration-block) present, tags with matching keys will overwrite those defined at the provider-level.

#### Attribute Reference

This resource exports the following attributes in addition to the arguments above:

* `arn` - ARN of the event bus.
* `id` - Name of the event bus.
* `tags_all` - Map of tags assigned to the resource, including those inherited from the provider [`default_tags` configuration block](https://registry.terraform.io/providers/hashicorp/aws/latest/docs#default_tags-configuration-block).

#### Import

In Terraform v1.5.0 and later, use an [`import` block](https://developer.hashicorp.com/terraform/language/import) to import EventBridge event buses using the `name` (which can also be a partner event source name). For example:

```terraform
import {
  to = aws_cloudwatch_event_bus.messenger
  id = "chat-messages"
}
```

Using `terraform import`, import EventBridge event buses using the name of the event bus (which can also be a partner event source name). For example:

```console
% terraform import aws_cloudwatch_event_bus.messenger chat-messages
```


// cloudwatch_event_bus_policy.html.markdown
---
subcategory: "EventBridge"
layout: "aws"
page_title: "AWS: aws_cloudwatch_event_bus_policy"
description: |-
  Provides a resource to create an EventBridge policy to support cross-account events.
---

### Resource: aws_cloudwatch_event_bus_policy

Provides a resource to create an EventBridge resource policy to support cross-account events.

~> **Note:** EventBridge was formerly known as CloudWatch Events. The functionality is identical.

~> **Note:** The EventBridge bus policy resource  (`aws_cloudwatch_event_bus_policy`) is incompatible with the EventBridge permission resource (`aws_cloudwatch_event_permission`) and will overwrite permissions.

#### Example Usage

##### Account Access

```hcl
data "aws_iam_policy_document" "test" {
  statement {
    sid    = "DevAccountAccess"
    effect = "Allow"
    actions = [
      "events:PutEvents",
    ]
    resources = [
      "arn:aws:events:eu-west-1:123456789012:event-bus/default"
    ]

    principals {
      type        = "AWS"
      identifiers = ["123456789012"]
    }
  }
}

resource "aws_cloudwatch_event_bus_policy" "test" {
  policy         = data.aws_iam_policy_document.test.json
  event_bus_name = aws_cloudwatch_event_bus.test.name
}
```

##### Organization Access

```hcl
data "aws_iam_policy_document" "test" {
  statement {
    sid    = "OrganizationAccess"
    effect = "Allow"
    actions = [
      "events:DescribeRule",
      "events:ListRules",
      "events:ListTargetsByRule",
      "events:ListTagsForResource",
    ]
    resources = [
      "arn:aws:events:eu-west-1:123456789012:rule/*",
      "arn:aws:events:eu-west-1:123456789012:event-bus/default"
    ]

    principals {
      type        = "AWS"
      identifiers = ["*"]
    }

    condition {
      test     = "StringEquals"
      variable = "aws:PrincipalOrgID"
      values   = [aws_organizations_organization.example.id]
    }
  }
}

resource "aws_cloudwatch_event_bus_policy" "test" {
  policy         = data.aws_iam_policy_document.test.json
  event_bus_name = aws_cloudwatch_event_bus.test.name
}
```

##### Multiple Statements

```hcl
data "aws_iam_policy_document" "test" {

  statement {
    sid    = "DevAccountAccess"
    effect = "Allow"
    actions = [
      "events:PutEvents",
    ]
    resources = [
      "arn:aws:events:eu-west-1:123456789012:event-bus/default"
    ]

    principals {
      type        = "AWS"
      identifiers = ["123456789012"]
    }
  }

  statement {
    sid    = "OrganizationAccess"
    effect = "Allow"
    actions = [
      "events:DescribeRule",
      "events:ListRules",
      "events:ListTargetsByRule",
      "events:ListTagsForResource",
    ]
    resources = [
      "arn:aws:events:eu-west-1:123456789012:rule/*",
      "arn:aws:events:eu-west-1:123456789012:event-bus/default"
    ]

    principals {
      type        = "AWS"
      identifiers = ["*"]
    }

    condition {
      test     = "StringEquals"
      variable = "aws:PrincipalOrgID"
      values   = [aws_organizations_organization.example.id]
    }
  }
}

resource "aws_cloudwatch_event_bus_policy" "test" {
  policy         = data.aws_iam_policy_document.test.json
  event_bus_name = aws_cloudwatch_event_bus.test.name
}
```

#### Argument Reference

This resource supports the following arguments:

* `policy` - (Required) The text of the policy. For more information about building AWS IAM policy documents with Terraform, see the [AWS IAM Policy Document Guide](https://learn.hashicorp.com/terraform/aws/iam-policy).
* `event_bus_name` - (Optional) The name of the event bus to set the permissions on.
  If you omit this, the permissions are set on the `default` event bus.

#### Attribute Reference

This resource exports the following attributes in addition to the arguments above:

* `id` - The name of the EventBridge event bus.

#### Import

In Terraform v1.5.0 and later, use an [`import` block](https://developer.hashicorp.com/terraform/language/import) to import an EventBridge policy using the `event_bus_name`. For example:

```terraform
import {
  to = aws_cloudwatch_event_bus_policy.DevAccountAccess
  id = "example-event-bus"
}
```

Using `terraform import`, import an EventBridge policy using the `event_bus_name`. For example:

```console
% terraform import aws_cloudwatch_event_bus_policy.DevAccountAccess example-event-bus
```


// cloudwatch_event_permission.html.markdown
---
subcategory: "EventBridge"
layout: "aws"
page_title: "AWS: aws_cloudwatch_event_permission"
description: |-
  Provides a resource to create an EventBridge permission to support cross-account events in the current account default event bus.
---

### Resource: aws_cloudwatch_event_permission

Provides a resource to create an EventBridge permission to support cross-account events in the current account default event bus.

~> **Note:** EventBridge was formerly known as CloudWatch Events. The functionality is identical.

~> **Note:** The EventBridge bus policy resource  (`aws_cloudwatch_event_bus_policy`) is incompatible with the EventBridge permission resource (`aws_cloudwatch_event_permission`) and will overwrite permissions.

#### Example Usage

##### Account Access

```terraform
resource "aws_cloudwatch_event_permission" "DevAccountAccess" {
  principal    = "123456789012"
  statement_id = "DevAccountAccess"
}
```

##### Organization Access

```terraform
resource "aws_cloudwatch_event_permission" "OrganizationAccess" {
  principal    = "*"
  statement_id = "OrganizationAccess"

  condition {
    key   = "aws:PrincipalOrgID"
    type  = "StringEquals"
    value = aws_organizations_organization.example.id
  }
}
```

#### Argument Reference

This resource supports the following arguments:

* `principal` - (Required) The 12-digit AWS account ID that you are permitting to put events to your default event bus. Specify `*` to permit any account to put events to your default event bus, optionally limited by `condition`.
* `statement_id` - (Required) An identifier string for the external account that you are granting permissions to.
* `action` - (Optional) The action that you are enabling the other account to perform. Defaults to `events:PutEvents`.
* `condition` - (Optional) Configuration block to limit the event bus permissions you are granting to only accounts that fulfill the condition. Specified below.
* `event_bus_name` - (Optional) The name of the event bus to set the permissions on.
  If you omit this, the permissions are set on the `default` event bus.

##### condition

* `key` - (Required) Key for the condition. Valid values: `aws:PrincipalOrgID`.
* `type` - (Required) Type of condition. Value values: `StringEquals`.
* `value` - (Required) Value for the key.

#### Attribute Reference

This resource exports the following attributes in addition to the arguments above:

* `id` - The statement ID of the EventBridge permission.

#### Import

In Terraform v1.5.0 and later, use an [`import` block](https://developer.hashicorp.com/terraform/language/import) to import EventBridge permissions using the `event_bus_name/statement_id` (if you omit `event_bus_name`, the `default` event bus will be used). For example:

```terraform
import {
  to = aws_cloudwatch_event_permission.DevAccountAccess
  id = "example-event-bus/DevAccountAccess"
}
```

Using `terraform import`, import EventBridge permissions using the `event_bus_name/statement_id` (if you omit `event_bus_name`, the `default` event bus will be used). For example:

```console
% terraform import aws_cloudwatch_event_permission.DevAccountAccess example-event-bus/DevAccountAccess
```

------------------------

## Notes

- Ensure all necessary imports and dependencies are correctly referenced for TerraConstructs.
- Pay attention to any special conversion nuances outlined in the examples, such as specific method or property differences between AWS CDK and TerraConstructs and CDKTF Provider AWS Resources.
- Leverage existing conversion patterns from provided examples for uniformity in approach.

## Simulated User Prompt
Convert the following AWS CDK Constructs to TerraConstructs.
```typescript
import { Match, Template } from '../../assertions';
import * as iam from '../../aws-iam';
import * as kms from '../../aws-kms';
import { App, Duration, Stack, CfnParameter, RemovalPolicy, CfnDeletionPolicy } from '../../core';
import { Stream, StreamEncryption, StreamMode } from '../lib';

describe('Kinesis data streams', () => {
  test('default stream', () => {
    const stack = new Stack();
    new Stream(stack, 'MyStream');

    Template.fromStack(stack).templateMatches({
      Resources: {
        MyStream5C050E93: {
          Type: 'AWS::Kinesis::Stream',
          Properties: {
            ShardCount: 1,
            RetentionPeriodHours: 24,
            StreamEncryption: {
              'Fn::If': [
                'AwsCdkKinesisEncryptedStreamsUnsupportedRegions',
                {
                  Ref: 'AWS::NoValue',
                },
                {
                  EncryptionType: 'KMS',
                  KeyId: 'alias/aws/kinesis',
                },
              ],
            },
          },
        },
      },
      Conditions: {
        AwsCdkKinesisEncryptedStreamsUnsupportedRegions: {
          'Fn::Or': [
            {
              'Fn::Equals': [
                {
                  Ref: 'AWS::Region',
                },
                'cn-north-1',
              ],
            },
            {
              'Fn::Equals': [
                {
                  Ref: 'AWS::Region',
                },
                'cn-northwest-1',
              ],
            },
          ],
        },
      },
    });
  }),

  test('multiple default streams only have one condition for encryption', () => {
    const stack = new Stack();
    new Stream(stack, 'MyStream');
    new Stream(stack, 'MyOtherStream');

    Template.fromStack(stack).templateMatches({
      Resources: {
        MyStream5C050E93: {
          Type: 'AWS::Kinesis::Stream',
          Properties: {
            ShardCount: 1,
            RetentionPeriodHours: 24,
            StreamEncryption: {
              'Fn::If': [
                'AwsCdkKinesisEncryptedStreamsUnsupportedRegions',
                {
                  Ref: 'AWS::NoValue',
                },
                {
                  EncryptionType: 'KMS',
                  KeyId: 'alias/aws/kinesis',
                },
              ],
            },
          },
        },
        MyOtherStream86FCC9CE: {
          Type: 'AWS::Kinesis::Stream',
          Properties: {
            ShardCount: 1,
            RetentionPeriodHours: 24,
            StreamEncryption: {
              'Fn::If': [
                'AwsCdkKinesisEncryptedStreamsUnsupportedRegions',
                {
                  Ref: 'AWS::NoValue',
                },
                {
                  EncryptionType: 'KMS',
                  KeyId: 'alias/aws/kinesis',
                },
              ],
            },
          },
        },
      },
      Conditions: {
        AwsCdkKinesisEncryptedStreamsUnsupportedRegions: {
          'Fn::Or': [
            {
              'Fn::Equals': [
                {
                  Ref: 'AWS::Region',
                },
                'cn-north-1',
              ],
            },
            {
              'Fn::Equals': [
                {
                  Ref: 'AWS::Region',
                },
                'cn-northwest-1',
              ],
            },
          ],
        },
      },
    });
  }),

  test('stream from attributes', () => {
    const stack = new Stack();
    const s = Stream.fromStreamAttributes(stack, 'MyStream', {
      streamArn: 'arn:aws:kinesis:region:account-id:stream/stream-name',
    });

    expect(s.streamArn).toEqual('arn:aws:kinesis:region:account-id:stream/stream-name');
  }),

  test('sets account for imported stream env by fromStreamAttributes', () => {
    const stack = new Stack();
    const imported = Stream.fromStreamAttributes(stack, 'Imported', {
      streamArn: 'arn:aws:kinesis:us-west-2:999999999999:stream/imported-stream',
    });

    expect(imported.env.account).toEqual('999999999999');
  });

  test('sets region for imported stream env by fromStreamAttributes', () => {
    const stack = new Stack();
    const imported = Stream.fromStreamAttributes(stack, 'Imported', {
      streamArn: 'arn:aws:kinesis:us-west-2:999999999999:stream/imported-stream',
    });

    expect(imported.env.region).toEqual('us-west-2');
  });

  test('sets account for imported stream env by fromStreamArn', () => {
    const stack = new Stack();
    const imported = Stream.fromStreamArn(stack, 'Imported', 'arn:aws:kinesis:us-west-2:999999999999:stream/imported-stream');

    expect(imported.env.account).toEqual('999999999999');
  });

  test('sets region for imported stream env by fromStreamArn', () => {
    const stack = new Stack();
    const imported = Stream.fromStreamArn(stack, 'Imported', 'arn:aws:kinesis:us-west-2:123456789012:stream/imported-stream');

    expect(imported.env.region).toEqual('us-west-2');
  });

  test('uses explicit shard count', () => {
    const stack = new Stack();
    new Stream(stack, 'MyStream', {
      shardCount: 2,
    });

    Template.fromStack(stack).templateMatches({
      Resources: {
        MyStream5C050E93: {
          Type: 'AWS::Kinesis::Stream',
          Properties: {
            ShardCount: 2,
            RetentionPeriodHours: 24,
            StreamEncryption: {
              'Fn::If': [
                'AwsCdkKinesisEncryptedStreamsUnsupportedRegions',
                {
                  Ref: 'AWS::NoValue',
                },
                {
                  EncryptionType: 'KMS',
                  KeyId: 'alias/aws/kinesis',
                },
              ],
            },
          },
        },
      },
      Conditions: {
        AwsCdkKinesisEncryptedStreamsUnsupportedRegions: {
          'Fn::Or': [
            {
              'Fn::Equals': [
                {
                  Ref: 'AWS::Region',
                },
                'cn-north-1',
              ],
            },
            {
              'Fn::Equals': [
                {
                  Ref: 'AWS::Region',
                },
                'cn-northwest-1',
              ],
            },
          ],
        },
      },
    });
  }),

  test('uses explicit retention period', () => {
    const stack = new Stack();
    new Stream(stack, 'MyStream', {
      retentionPeriod: Duration.hours(168),
    });

    Template.fromStack(stack).templateMatches({
      Resources: {
        MyStream5C050E93: {
          Type: 'AWS::Kinesis::Stream',
          Properties: {
            ShardCount: 1,
            RetentionPeriodHours: 168,
            StreamEncryption: {
              'Fn::If': [
                'AwsCdkKinesisEncryptedStreamsUnsupportedRegions',
                {
                  Ref: 'AWS::NoValue',
                },
                {
                  EncryptionType: 'KMS',
                  KeyId: 'alias/aws/kinesis',
                },
              ],
            },
          },
        },
      },
      Conditions: {
        AwsCdkKinesisEncryptedStreamsUnsupportedRegions: {
          'Fn::Or': [
            {
              'Fn::Equals': [
                {
                  Ref: 'AWS::Region',
                },
                'cn-north-1',
              ],
            },
            {
              'Fn::Equals': [
                {
                  Ref: 'AWS::Region',
                },
                'cn-northwest-1',
              ],
            },
          ],
        },
      },
    });
  }),

  test('retention period must be between 24 and 8760 hours', () => {
    expect(() => {
      new Stream(new Stack(), 'MyStream', {
        retentionPeriod: Duration.hours(8761),
      });
    }).toThrow(/retentionPeriod must be between 24 and 8760 hours. Received 8761/);

    expect(() => {
      new Stream(new Stack(), 'MyStream', {
        retentionPeriod: Duration.hours(23),
      });
    }).toThrow(/retentionPeriod must be between 24 and 8760 hours. Received 23/);
  }),

  test('uses Kinesis master key if MANAGED encryption type is provided', () => {
    // GIVEN
    const stack = new Stack();

    // WHEN
    new Stream(stack, 'MyStream', {
      encryption: StreamEncryption.MANAGED,
    });

    // THEN
    Template.fromStack(stack).templateMatches({
      Resources: {
        MyStream5C050E93: {
          Type: 'AWS::Kinesis::Stream',
          Properties: {
            ShardCount: 1,
            RetentionPeriodHours: 24,
            StreamEncryption: {
              EncryptionType: 'KMS',
              KeyId: 'alias/aws/kinesis',
            },
          },
        },
      },
    });
  }),

  test('encryption key cannot be supplied with UNENCRYPTED as the encryption type', () => {
    const stack = new Stack();
    const key = new kms.Key(stack, 'myKey');

    expect(() => {
      new Stream(stack, 'MyStream', {
        encryptionKey: key,
        encryption: StreamEncryption.UNENCRYPTED,
      });
    }).toThrow(/encryptionKey is specified, so 'encryption' must be set to KMS/);
  }),

  test('if a KMS key is supplied, infers KMS as the encryption type', () => {
    // GIVEN
    const stack = new Stack();
    const key = new kms.Key(stack, 'myKey');

    // WHEN
    new Stream(stack, 'myStream', {
      encryptionKey: key,
    });

    // THEN
    Template.fromStack(stack).hasResourceProperties('AWS::Kinesis::Stream', {
      ShardCount: 1,
      RetentionPeriodHours: 24,
      StreamEncryption: {
        EncryptionType: 'KMS',
        KeyId: {
          'Fn::GetAtt': ['myKey441A1E73', 'Arn'],
        },
      },
    });
  }),

  test('auto-creates KMS key if encryption type is KMS but no key is provided', () => {
    const stack = new Stack();
    const stream = new Stream(stack, 'MyStream', {
      encryption: StreamEncryption.KMS,
    });

    Template.fromStack(stack).hasResourceProperties('AWS::KMS::Key', {
      Description: 'Created by Default/MyStream',
    });

    Template.fromStack(stack).hasResourceProperties('AWS::Kinesis::Stream', {
      StreamEncryption: {
        EncryptionType: 'KMS',
        KeyId: stack.resolve(stream.encryptionKey?.keyArn),
      },
    });
  }),

  test('uses explicit KMS key if encryption type is KMS and a key is provided', () => {
    const stack = new Stack();
    const explicitKey = new kms.Key(stack, 'ExplicitKey', {
      description: 'Explicit Key',
    });
    new Stream(stack, 'MyStream', {
      encryption: StreamEncryption.KMS,
      encryptionKey: explicitKey,
    });

    Template.fromStack(stack).hasResourceProperties('AWS::KMS::Key', {
      Description: 'Explicit Key',
    });

    Template.fromStack(stack).hasResourceProperties('AWS::Kinesis::Stream', {
      ShardCount: 1,
      RetentionPeriodHours: 24,
      StreamEncryption: {
        EncryptionType: 'KMS',
        KeyId: stack.resolve(explicitKey.keyArn),
      },
    });
  }),

  test('uses explicit provisioned streamMode', () => {
    const stack = new Stack();
    new Stream(stack, 'MyStream', {
      streamMode: StreamMode.PROVISIONED,
    });

    Template.fromStack(stack).templateMatches({
      Resources: {
        MyStream5C050E93: {
          Type: 'AWS::Kinesis::Stream',
          Properties: {
            RetentionPeriodHours: 24,
            ShardCount: 1,
            StreamModeDetails: {
              StreamMode: StreamMode.PROVISIONED,
            },
            StreamEncryption: {
              'Fn::If': [
                'AwsCdkKinesisEncryptedStreamsUnsupportedRegions',
                {
                  Ref: 'AWS::NoValue',
                },
                {
                  EncryptionType: 'KMS',
                  KeyId: 'alias/aws/kinesis',
                },
              ],
            },
          },
        },
      },
      Conditions: {
        AwsCdkKinesisEncryptedStreamsUnsupportedRegions: {
          'Fn::Or': [
            {
              'Fn::Equals': [
                {
                  Ref: 'AWS::Region',
                },
                'cn-north-1',
              ],
            },
            {
              'Fn::Equals': [
                {
                  Ref: 'AWS::Region',
                },
                'cn-northwest-1',
              ],
            },
          ],
        },
      },
    });
  });

  test('uses explicit on-demand streamMode', () => {
    const stack = new Stack();
    new Stream(stack, 'MyStream', {
      streamMode: StreamMode.ON_DEMAND,
    });

    Template.fromStack(stack).templateMatches({
      Resources: {
        MyStream5C050E93: {
          Type: 'AWS::Kinesis::Stream',
          Properties: {
            RetentionPeriodHours: 24,
            StreamModeDetails: {
              StreamMode: StreamMode.ON_DEMAND,
            },
            StreamEncryption: {
              'Fn::If': [
                'AwsCdkKinesisEncryptedStreamsUnsupportedRegions',
                {
                  Ref: 'AWS::NoValue',
                },
                {
                  EncryptionType: 'KMS',
                  KeyId: 'alias/aws/kinesis',
                },
              ],
            },
          },
        },
      },
      Conditions: {
        AwsCdkKinesisEncryptedStreamsUnsupportedRegions: {
          'Fn::Or': [
            {
              'Fn::Equals': [
                {
                  Ref: 'AWS::Region',
                },
                'cn-north-1',
              ],
            },
            {
              'Fn::Equals': [
                {
                  Ref: 'AWS::Region',
                },
                'cn-northwest-1',
              ],
            },
          ],
        },
      },
    });
  });

  test('throws when using shardCount with on-demand streamMode', () => {
    const stack = new Stack();

    expect(() => {
      new Stream(stack, 'MyStream', {
        shardCount: 2,
        streamMode: StreamMode.ON_DEMAND,
      });
    }).toThrow(`streamMode must be set to ${StreamMode.PROVISIONED} (default) when specifying shardCount`);
  });

  test('grantRead creates and attaches a policy with read only access to the principal', () => {
    const stack = new Stack();
    const stream = new Stream(stack, 'MyStream', {
      encryption: StreamEncryption.KMS,
    });
    const user = new iam.User(stack, 'MyUser');
    stream.grantRead(user);

    Template.fromStack(stack).hasResourceProperties('AWS::IAM::Policy', {
      PolicyDocument: {
        Statement: Match.arrayWith([{
          Action: 'kms:Decrypt',
          Effect: 'Allow',
          Resource: stack.resolve(stream.encryptionKey?.keyArn),
        }]),
      },
    });

    Template.fromStack(stack).hasResourceProperties('AWS::Kinesis::Stream', {
      StreamEncryption: {
        KeyId: stack.resolve(stream.encryptionKey?.keyArn),
      },
    });
  });

  test('grantReadWrite creates and attaches a policy to the principal', () => {
    const stack = new Stack();
    const stream = new Stream(stack, 'MyStream', {
      encryption: StreamEncryption.KMS,
    });
    const user = new iam.User(stack, 'MyUser');
    stream.grantReadWrite(user);

    Template.fromStack(stack).hasResourceProperties('AWS::IAM::Policy', {
      PolicyDocument: {
        Statement: Match.arrayWith([{
          Action: ['kms:Decrypt', 'kms:Encrypt', 'kms:ReEncrypt*', 'kms:GenerateDataKey*'],
          Effect: 'Allow',
          Resource: stack.resolve(stream.encryptionKey?.keyArn),
        }]),
      },
    });

    Template.fromStack(stack).hasResourceProperties('AWS::Kinesis::Stream', {
      StreamEncryption: {
        KeyId: stack.resolve(stream.encryptionKey?.keyArn),
      },
    });
  });

  test('grantRead creates and associates a policy with read only access to Stream', () => {
    const stack = new Stack();
    const stream = new Stream(stack, 'MyStream');
    const user = new iam.User(stack, 'MyUser');
    stream.grantRead(user);

    Template.fromStack(stack).templateMatches({
      Resources: {
        MyStream5C050E93: {
          Type: 'AWS::Kinesis::Stream',
          Properties: {
            ShardCount: 1,
            RetentionPeriodHours: 24,
            StreamEncryption: {
              'Fn::If': [
                'AwsCdkKinesisEncryptedStreamsUnsupportedRegions',
                {
                  Ref: 'AWS::NoValue',
                },
                {
                  EncryptionType: 'KMS',
                  KeyId: 'alias/aws/kinesis',
                },
              ],
            },
          },
        },
        MyUserDC45028B: {
          Type: 'AWS::IAM::User',
        },
        MyUserDefaultPolicy7B897426: {
          Type: 'AWS::IAM::Policy',
          Properties: {
            PolicyDocument: {
              Statement: [
                {
                  Action: [
                    'kinesis:DescribeStreamSummary',
                    'kinesis:GetRecords',
                    'kinesis:GetShardIterator',
                    'kinesis:ListShards',
                    'kinesis:SubscribeToShard',
                    'kinesis:DescribeStream',
                    'kinesis:ListStreams',
                    'kinesis:DescribeStreamConsumer',
                  ],
                  Effect: 'Allow',
                  Resource: {
                    'Fn::GetAtt': ['MyStream5C050E93', 'Arn'],
                  },
                },
              ],
              Version: '2012-10-17',
            },
            PolicyName: 'MyUserDefaultPolicy7B897426',
            Users: [
              {
                Ref: 'MyUserDC45028B',
              },
            ],
          },
        },
      },
      Conditions: {
        AwsCdkKinesisEncryptedStreamsUnsupportedRegions: {
          'Fn::Or': [
            {
              'Fn::Equals': [
                {
                  Ref: 'AWS::Region',
                },
                'cn-north-1',
              ],
            },
            {
              'Fn::Equals': [
                {
                  Ref: 'AWS::Region',
                },
                'cn-northwest-1',
              ],
            },
          ],
        },
      },
    });
  }),

  test('grantWrite creates and attaches a policy with write only access to Stream', () => {
    const stack = new Stack();
    const stream = new Stream(stack, 'MyStream');
    const user = new iam.User(stack, 'MyUser');
    stream.grantWrite(user);

    Template.fromStack(stack).templateMatches({
      Resources: {
        MyStream5C050E93: {
          Type: 'AWS::Kinesis::Stream',
          Properties: {
            ShardCount: 1,
            RetentionPeriodHours: 24,
            StreamEncryption: {
              'Fn::If': [
                'AwsCdkKinesisEncryptedStreamsUnsupportedRegions',
                {
                  Ref: 'AWS::NoValue',
                },
                {
                  EncryptionType: 'KMS',
                  KeyId: 'alias/aws/kinesis',
                },
              ],
            },
          },
        },
        MyUserDC45028B: {
          Type: 'AWS::IAM::User',
        },
        MyUserDefaultPolicy7B897426: {
          Type: 'AWS::IAM::Policy',
          Properties: {
            PolicyDocument: {
              Statement: [
                {
                  Action: ['kinesis:ListShards', 'kinesis:PutRecord', 'kinesis:PutRecords'],
                  Effect: 'Allow',
                  Resource: {
                    'Fn::GetAtt': ['MyStream5C050E93', 'Arn'],
                  },
                },
              ],
              Version: '2012-10-17',
            },
            PolicyName: 'MyUserDefaultPolicy7B897426',
            Users: [
              {
                Ref: 'MyUserDC45028B',
              },
            ],
          },
        },
      },
      Conditions: {
        AwsCdkKinesisEncryptedStreamsUnsupportedRegions: {
          'Fn::Or': [
            {
              'Fn::Equals': [
                {
                  Ref: 'AWS::Region',
                },
                'cn-north-1',
              ],
            },
            {
              'Fn::Equals': [
                {
                  Ref: 'AWS::Region',
                },
                'cn-northwest-1',
              ],
            },
          ],
        },
      },
    });
  }),

  test('grantReadWrite creates and attaches a policy with write only access to Stream', () => {
    const stack = new Stack();
    const stream = new Stream(stack, 'MyStream');
    const user = new iam.User(stack, 'MyUser');
    stream.grantReadWrite(user);

    Template.fromStack(stack).templateMatches({
      Resources: {
        MyStream5C050E93: {
          Type: 'AWS::Kinesis::Stream',
          Properties: {
            ShardCount: 1,
            RetentionPeriodHours: 24,
            StreamEncryption: {
              'Fn::If': [
                'AwsCdkKinesisEncryptedStreamsUnsupportedRegions',
                {
                  Ref: 'AWS::NoValue',
                },
                {
                  EncryptionType: 'KMS',
                  KeyId: 'alias/aws/kinesis',
                },
              ],
            },
          },
        },
        MyUserDC45028B: {
          Type: 'AWS::IAM::User',
        },
        MyUserDefaultPolicy7B897426: {
          Type: 'AWS::IAM::Policy',
          Properties: {
            PolicyDocument: {
              Statement: [
                {
                  Action: [
                    'kinesis:DescribeStreamSummary',
                    'kinesis:GetRecords',
                    'kinesis:GetShardIterator',
                    'kinesis:ListShards',
                    'kinesis:SubscribeToShard',
                    'kinesis:DescribeStream',
                    'kinesis:ListStreams',
                    'kinesis:DescribeStreamConsumer',
                    'kinesis:PutRecord',
                    'kinesis:PutRecords',
                  ],
                  Effect: 'Allow',
                  Resource: {
                    'Fn::GetAtt': ['MyStream5C050E93', 'Arn'],
                  },
                },
              ],
              Version: '2012-10-17',
            },
            PolicyName: 'MyUserDefaultPolicy7B897426',
            Users: [
              {
                Ref: 'MyUserDC45028B',
              },
            ],
          },
        },
      },
      Conditions: {
        AwsCdkKinesisEncryptedStreamsUnsupportedRegions: {
          'Fn::Or': [
            {
              'Fn::Equals': [
                {
                  Ref: 'AWS::Region',
                },
                'cn-north-1',
              ],
            },
            {
              'Fn::Equals': [
                {
                  Ref: 'AWS::Region',
                },
                'cn-northwest-1',
              ],
            },
          ],
        },
      },
    });
  }),

  test('grant creates and attaches a policy to Stream which includes supplied permissions', () => {
    const stack = new Stack();
    const stream = new Stream(stack, 'MyStream');
    const user = new iam.User(stack, 'MyUser');
    stream.grant(user, 'kinesis:DescribeStream');

    Template.fromStack(stack).templateMatches({
      Resources: {
        MyStream5C050E93: {
          Type: 'AWS::Kinesis::Stream',
          Properties: {
            ShardCount: 1,
            RetentionPeriodHours: 24,
            StreamEncryption: {
              'Fn::If': [
                'AwsCdkKinesisEncryptedStreamsUnsupportedRegions',
                {
                  Ref: 'AWS::NoValue',
                },
                {
                  EncryptionType: 'KMS',
                  KeyId: 'alias/aws/kinesis',
                },
              ],
            },
          },
        },
        MyUserDC45028B: {
          Type: 'AWS::IAM::User',
        },
        MyUserDefaultPolicy7B897426: {
          Type: 'AWS::IAM::Policy',
          Properties: {
            PolicyDocument: {
              Statement: [
                {
                  Action: 'kinesis:DescribeStream',
                  Effect: 'Allow',
                  Resource: {
                    'Fn::GetAtt': ['MyStream5C050E93', 'Arn'],
                  },
                },
              ],
              Version: '2012-10-17',
            },
            PolicyName: 'MyUserDefaultPolicy7B897426',
            Users: [
              {
                Ref: 'MyUserDC45028B',
              },
            ],
          },
        },
      },
      Conditions: {
        AwsCdkKinesisEncryptedStreamsUnsupportedRegions: {
          'Fn::Or': [
            {
              'Fn::Equals': [
                {
                  Ref: 'AWS::Region',
                },
                'cn-north-1',
              ],
            },
            {
              'Fn::Equals': [
                {
                  Ref: 'AWS::Region',
                },
                'cn-northwest-1',
              ],
            },
          ],
        },
      },
    });
  }),

  test('cross-stack permissions - no encryption', () => {
    const app = new App();
    const stackA = new Stack(app, 'stackA');
    const streamFromStackA = new Stream(stackA, 'MyStream');

    const stackB = new Stack(app, 'stackB');
    const user = new iam.User(stackB, 'UserWhoNeedsAccess');
    streamFromStackA.grantRead(user);

    Template.fromStack(stackA).templateMatches({
      Resources: {
        MyStream5C050E93: {
          Type: 'AWS::Kinesis::Stream',
          Properties: {
            ShardCount: 1,
            RetentionPeriodHours: 24,
            StreamEncryption: {
              'Fn::If': [
                'AwsCdkKinesisEncryptedStreamsUnsupportedRegions',
                {
                  Ref: 'AWS::NoValue',
                },
                {
                  EncryptionType: 'KMS',
                  KeyId: 'alias/aws/kinesis',
                },
              ],
            },
          },
        },
      },
      Conditions: {
        AwsCdkKinesisEncryptedStreamsUnsupportedRegions: {
          'Fn::Or': [
            {
              'Fn::Equals': [
                {
                  Ref: 'AWS::Region',
                },
                'cn-north-1',
              ],
            },
            {
              'Fn::Equals': [
                {
                  Ref: 'AWS::Region',
                },
                'cn-northwest-1',
              ],
            },
          ],
        },
      },
      Outputs: {
        ExportsOutputFnGetAttMyStream5C050E93Arn4ABF30CD: {
          Value: {
            'Fn::GetAtt': ['MyStream5C050E93', 'Arn'],
          },
          Export: {
            Name: 'stackA:ExportsOutputFnGetAttMyStream5C050E93Arn4ABF30CD',
          },
        },
      },
    });
  }),

  test('cross stack permissions - with encryption', () => {
    const app = new App();
    const stackA = new Stack(app, 'stackA');
    const streamFromStackA = new Stream(stackA, 'MyStream', {
      encryption: StreamEncryption.KMS,
    });

    const stackB = new Stack(app, 'stackB');
    const user = new iam.User(stackB, 'UserWhoNeedsAccess');
    streamFromStackA.grantRead(user);

    Template.fromStack(stackB).hasResourceProperties('AWS::IAM::Policy', {
      PolicyDocument: {
        Statement: Match.arrayWith([{
          Action: 'kms:Decrypt',
          Effect: 'Allow',
          Resource: {
            'Fn::ImportValue': 'stackA:ExportsOutputFnGetAttMyStreamKey76F3300EArn190947B4',
          },
        }]),
      },
    });
  });

  test('accepts if retentionPeriodHours is a Token', () => {
    const stack = new Stack();
    const parameter = new CfnParameter(stack, 'my-retention-period', {
      type: 'Number',
      default: 48,
      minValue: 24,
      maxValue: 8760,
    });

    new Stream(stack, 'MyStream', {
      retentionPeriod: Duration.hours(parameter.valueAsNumber),
    });

    Template.fromStack(stack).templateMatches({
      Parameters: {
        myretentionperiod: {
          Type: 'Number',
          Default: 48,
          MaxValue: 8760,
          MinValue: 24,
        },
      },
      Resources: {
        MyStream5C050E93: {
          Type: 'AWS::Kinesis::Stream',
          Properties: {
            ShardCount: 1,
            RetentionPeriodHours: {
              Ref: 'myretentionperiod',
            },
            StreamEncryption: {
              'Fn::If': [
                'AwsCdkKinesisEncryptedStreamsUnsupportedRegions',
                {
                  Ref: 'AWS::NoValue',
                },
                {
                  EncryptionType: 'KMS',
                  KeyId: 'alias/aws/kinesis',
                },
              ],
            },
          },
        },
      },
      Conditions: {
        AwsCdkKinesisEncryptedStreamsUnsupportedRegions: {
          'Fn::Or': [
            {

              'Fn::Equals': [
                {
                  Ref: 'AWS::Region',
                },
                'cn-north-1',
              ],
            },
            {
              'Fn::Equals': [
                {
                  Ref: 'AWS::Region',
                },
                'cn-northwest-1',
              ],
            },
          ],
        },
      },
    });
  });

  test('basic stream-level metrics (StreamName dimension only)', () => {
    // GIVEN
    const stack = new Stack();
    const fiveMinutes = {
      amount: 5,
      unit: {
        label: 'minutes',
        isoLabel: 'M',
        inMillis: 60000,
      },
    };

    // WHEN
    const stream = new Stream(stack, 'MyStream');

    // THEN
    // should resolve the basic metrics (source https://docs.aws.amazon.com/streams/latest/dev/monitoring-with-cloudwatch.html#kinesis-metrics-stream)
    expect(stack.resolve(stream.metricGetRecordsBytes())).toEqual({
      dimensions: { StreamName: { Ref: 'MyStream5C050E93' } },
      namespace: 'AWS/Kinesis',
      metricName: 'GetRecords.Bytes',
      period: fiveMinutes,
      statistic: 'Average',
    });

    expect(stack.resolve(stream.metricGetRecordsIteratorAgeMilliseconds())).toEqual({
      dimensions: { StreamName: { Ref: 'MyStream5C050E93' } },
      namespace: 'AWS/Kinesis',
      metricName: 'GetRecords.IteratorAgeMilliseconds',
      period: fiveMinutes,
      statistic: 'Maximum',
    });

    expect(stack.resolve(stream.metricGetRecordsLatency())).toEqual({
      dimensions: { StreamName: { Ref: 'MyStream5C050E93' } },
      namespace: 'AWS/Kinesis',
      metricName: 'GetRecords.Latency',
      period: fiveMinutes,
      statistic: 'Average',
    });

    expect(stack.resolve(stream.metricGetRecords())).toEqual({
      dimensions: { StreamName: { Ref: 'MyStream5C050E93' } },
      namespace: 'AWS/Kinesis',
      metricName: 'GetRecords.Records',
      period: fiveMinutes,
      statistic: 'Average',
    });

    expect(stack.resolve(stream.metricGetRecordsSuccess())).toEqual({
      dimensions: { StreamName: { Ref: 'MyStream5C050E93' } },
      namespace: 'AWS/Kinesis',
      metricName: 'GetRecords.Success',
      period: fiveMinutes,
      statistic: 'Average',
    });

    expect(stack.resolve(stream.metricIncomingBytes())).toEqual({
      dimensions: { StreamName: { Ref: 'MyStream5C050E93' } },
      namespace: 'AWS/Kinesis',
      metricName: 'IncomingBytes',
      period: fiveMinutes,
      statistic: 'Average',
    });

    expect(stack.resolve(stream.metricIncomingRecords())).toEqual({
      dimensions: { StreamName: { Ref: 'MyStream5C050E93' } },
      namespace: 'AWS/Kinesis',
      metricName: 'IncomingRecords',
      period: fiveMinutes,
      statistic: 'Average',
    });

    expect(stack.resolve(stream.metricPutRecordsBytes())).toEqual({
      dimensions: { StreamName: { Ref: 'MyStream5C050E93' } },
      namespace: 'AWS/Kinesis',
      metricName: 'PutRecords.Bytes',
      period: fiveMinutes,
      statistic: 'Average',
    });

    expect(stack.resolve(stream.metricPutRecordsLatency())).toEqual({
      dimensions: { StreamName: { Ref: 'MyStream5C050E93' } },
      namespace: 'AWS/Kinesis',
      metricName: 'PutRecords.Latency',
      period: fiveMinutes,
      statistic: 'Average',
    });

    expect(stack.resolve(stream.metricPutRecordsSuccess())).toEqual({
      dimensions: { StreamName: { Ref: 'MyStream5C050E93' } },
      namespace: 'AWS/Kinesis',
      metricName: 'PutRecords.Success',
      period: fiveMinutes,
      statistic: 'Average',
    });

    expect(stack.resolve(stream.metricPutRecordsTotalRecords())).toEqual({
      dimensions: { StreamName: { Ref: 'MyStream5C050E93' } },
      namespace: 'AWS/Kinesis',
      metricName: 'PutRecords.TotalRecords',
      period: fiveMinutes,
      statistic: 'Average',
    });

    expect(stack.resolve(stream.metricPutRecordsSuccessfulRecords())).toEqual({
      dimensions: { StreamName: { Ref: 'MyStream5C050E93' } },
      namespace: 'AWS/Kinesis',
      metricName: 'PutRecords.SuccessfulRecords',
      period: fiveMinutes,
      statistic: 'Average',
    });

    expect(stack.resolve(stream.metricPutRecordsFailedRecords())).toEqual({
      dimensions: { StreamName: { Ref: 'MyStream5C050E93' } },
      namespace: 'AWS/Kinesis',
      metricName: 'PutRecords.FailedRecords',
      period: fiveMinutes,
      statistic: 'Average',
    });

    expect(stack.resolve(stream.metricPutRecordsThrottledRecords())).toEqual({
      dimensions: { StreamName: { Ref: 'MyStream5C050E93' } },
      namespace: 'AWS/Kinesis',
      metricName: 'PutRecords.ThrottledRecords',
      period: fiveMinutes,
      statistic: 'Average',
    });

    expect(stack.resolve(stream.metricReadProvisionedThroughputExceeded())).toEqual({
      dimensions: { StreamName: { Ref: 'MyStream5C050E93' } },
      namespace: 'AWS/Kinesis',
      metricName: 'ReadProvisionedThroughputExceeded',
      period: fiveMinutes,
      statistic: 'Average',
    });

    expect(stack.resolve(stream.metricWriteProvisionedThroughputExceeded())).toEqual({
      dimensions: { StreamName: { Ref: 'MyStream5C050E93' } },
      namespace: 'AWS/Kinesis',
      metricName: 'WriteProvisionedThroughputExceeded',
      period: fiveMinutes,
      statistic: 'Average',
    });
  });

  test('allow to overide metric options', () => {
    // GIVEN
    const stack = new Stack();
    const fiveMinutes = {
      amount: 5,
      unit: {
        label: 'minutes',
        isoLabel: 'M',
        inMillis: 60000,
      },
    };

    // WHEN
    const stream = new Stream(stack, 'MyStream');

    // THEN
    expect(stack.resolve(stream.metricGetRecordsBytes())).toEqual({
      dimensions: { StreamName: { Ref: 'MyStream5C050E93' } },
      namespace: 'AWS/Kinesis',
      metricName: 'GetRecords.Bytes',
      period: fiveMinutes,
      statistic: 'Average',
    });

    expect(stack.resolve(stream.metricGetRecordsBytes({
      period: Duration.minutes(1),
      statistic: 'Maximum',
    }))).toEqual({
      dimensions: { StreamName: { Ref: 'MyStream5C050E93' } },
      namespace: 'AWS/Kinesis',
      metricName: 'GetRecords.Bytes',
      period: { ...fiveMinutes, amount: 1 },
      statistic: 'Maximum',
    });

    expect(stack.resolve(stream.metricIncomingBytes())).toEqual({
      dimensions: { StreamName: { Ref: 'MyStream5C050E93' } },
      namespace: 'AWS/Kinesis',
      metricName: 'IncomingBytes',
      period: fiveMinutes,
      statistic: 'Average',
    });

    expect(stack.resolve(stream.metricIncomingBytes({
      period: Duration.minutes(1),
      statistic: 'Sum',
    }))).toEqual({
      dimensions: { StreamName: { Ref: 'MyStream5C050E93' } },
      namespace: 'AWS/Kinesis',
      metricName: 'IncomingBytes',
      period: { ...fiveMinutes, amount: 1 },
      statistic: 'Sum',
    });
  });

  test('with default removal policy', () => {
    // GIVEN
    const stack = new Stack();

    // WHEN
    new Stream(stack, 'Stream');

    // THEN
    Template.fromStack(stack).hasResource('AWS::Kinesis::Stream', {
      DeletionPolicy: CfnDeletionPolicy.RETAIN,
    });
  });

  test('with removal policy as DESTROY', () => {
    // GIVEN
    const stack = new Stack();

    // WHEN
    new Stream(stack, 'Stream', {
      removalPolicy: RemovalPolicy.DESTROY,
    });

    // THEN
    Template.fromStack(stack).hasResource('AWS::Kinesis::Stream', {
      DeletionPolicy: CfnDeletionPolicy.DELETE,
    });
  });

  test('addToResourcePolicy will automatically create a policy for this stream', () => {
    // GIVEN
    const stack = new Stack();
    const stream = new Stream(stack, 'Stream', {});

    // WHEN
    stream.addToResourcePolicy(new iam.PolicyStatement({
      actions: ['kinesis:GetRecords'],
      principals: [new iam.AnyPrincipal()],
      resources: [stream.streamArn],
    }));

    // THEN
    Template.fromStack(stack).hasResourceProperties('AWS::Kinesis::ResourcePolicy', {
      ResourcePolicy: {
        Version: '2012-10-17',
        Statement: [
          {
            Action: 'kinesis:GetRecords',
            Effect: 'Allow',
            Principal: { AWS: '*' },
            Resource: stack.resolve(stream.streamArn),
          },
        ],
      },
    });
  });
});

```

## Reference Documents
**AWS CDK Tested Construct Type Declarations:**
Refer to the following Reference declarations used by the AWSCDK constructs:
```typescript
// stream.d.ts
import { Construct } from 'constructs';
import * as cloudwatch from '../../aws-cloudwatch';
import * as iam from '../../aws-iam';
import * as kms from '../../aws-kms';
import { Duration, IResource, RemovalPolicy, Resource, ResourceProps } from '../../core';
/**
 * A Kinesis Stream
 */
export interface IStream extends IResource {
    /**
     * The ARN of the stream.
     *
     * @attribute
     */
    readonly streamArn: string;
    /**
     * The name of the stream
     *
     * @attribute
     */
    readonly streamName: string;
    /**
     * Optional KMS encryption key associated with this stream.
     */
    readonly encryptionKey?: kms.IKey;
    /**
     * Adds a statement to the IAM resource policy associated with this stream.
     *
     * If this stream was created in this stack (`new Stream`), a resource policy
     * will be automatically created upon the first call to `addToResourcePolicy`. If
     * the stream is imported (`Stream.import`), then this is a no-op.
     */
    addToResourcePolicy(statement: iam.PolicyStatement): iam.AddToResourcePolicyResult;
    /**
     * Grant read permissions for this stream and its contents to an IAM
     * principal (Role/Group/User).
     *
     * If an encryption key is used, permission to ues the key to decrypt the
     * contents of the stream will also be granted.
     */
    grantRead(grantee: iam.IGrantable): iam.Grant;
    /**
     * Grant write permissions for this stream and its contents to an IAM
     * principal (Role/Group/User).
     *
     * If an encryption key is used, permission to ues the key to encrypt the
     * contents of the stream will also be granted.
     */
    grantWrite(grantee: iam.IGrantable): iam.Grant;
    /**
     * Grants read/write permissions for this stream and its contents to an IAM
     * principal (Role/Group/User).
     *
     * If an encryption key is used, permission to use the key for
     * encrypt/decrypt will also be granted.
     */
    grantReadWrite(grantee: iam.IGrantable): iam.Grant;
    /**
     * Grant the indicated permissions on this stream to the provided IAM principal.
     */
    grant(grantee: iam.IGrantable, ...actions: string[]): iam.Grant;
    /**
     * Return stream metric based from its metric name
     *
     * @param metricName name of the stream metric
     * @param props properties of the metric
     */
    metric(metricName: string, props?: cloudwatch.MetricOptions): cloudwatch.Metric;
    /**
     * The number of bytes retrieved from the Kinesis stream, measured over the specified time period. Minimum, Maximum,
     * and Average statistics represent the bytes in a single GetRecords operation for the stream in the specified time
     * period.
     *
     * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
     *
     * @param props properties of the metric
     */
    metricGetRecordsBytes(props?: cloudwatch.MetricOptions): cloudwatch.Metric;
    /**
     * The age of the last record in all GetRecords calls made against a Kinesis stream, measured over the specified time
     * period. Age is the difference between the current time and when the last record of the GetRecords call was written
     * to the stream. The Minimum and Maximum statistics can be used to track the progress of Kinesis consumer
     * applications. A value of zero indicates that the records being read are completely caught up with the stream.
     *
     * The metric defaults to maximum over 5 minutes, it can be changed by passing `statistic` and `period` properties.
     *
     * @param props properties of the metric
     */
    metricGetRecordsIteratorAgeMilliseconds(props?: cloudwatch.MetricOptions): cloudwatch.Metric;
    /**
     * The time taken per GetRecords operation, measured over the specified time period.
     *
     * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
     *
     * @param props properties of the metric
     */
    metricGetRecordsLatency(props?: cloudwatch.MetricOptions): cloudwatch.Metric;
    /**
     * The number of records retrieved from the shard, measured over the specified time period. Minimum, Maximum, and
     * Average statistics represent the records in a single GetRecords operation for the stream in the specified time
     * period.
     *
     * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
     *
     * @param props properties of the metric
     */
    metricGetRecords(props?: cloudwatch.MetricOptions): cloudwatch.Metric;
    /**
     * The number of successful GetRecords operations per stream, measured over the specified time period.
     *
     * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
     *
     * @param props properties of the metric
     */
    metricGetRecordsSuccess(props?: cloudwatch.MetricOptions): cloudwatch.Metric;
    /**
     * The number of bytes successfully put to the Kinesis stream over the specified time period. This metric includes
     * bytes from PutRecord and PutRecords operations. Minimum, Maximum, and Average statistics represent the bytes in a
     * single put operation for the stream in the specified time period.
     *
     * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
     *
     * @param props properties of the metric
     */
    metricIncomingBytes(props?: cloudwatch.MetricOptions): cloudwatch.Metric;
    /**
     * The number of records successfully put to the Kinesis stream over the specified time period. This metric includes
     * record counts from PutRecord and PutRecords operations. Minimum, Maximum, and Average statistics represent the
     * records in a single put operation for the stream in the specified time period.
     *
     * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
     *
     * @param props properties of the metric
     */
    metricIncomingRecords(props?: cloudwatch.MetricOptions): cloudwatch.Metric;
    /**
     * The number of bytes put to the Kinesis stream using the PutRecord operation over the specified time period.
     *
     * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
     *
     * @param props properties of the metric
     */
    metricPutRecordBytes(props?: cloudwatch.MetricOptions): cloudwatch.Metric;
    /**
     * The time taken per PutRecord operation, measured over the specified time period.
     *
     * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
     *
     * @param props properties of the metric
     */
    metricPutRecordLatency(props?: cloudwatch.MetricOptions): cloudwatch.Metric;
    /**
     * The number of successful PutRecord operations per Kinesis stream, measured over the specified time period. Average
     * reflects the percentage of successful writes to a stream.
     *
     * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
     *
     * @param props properties of the metric
     */
    metricPutRecordSuccess(props?: cloudwatch.MetricOptions): cloudwatch.Metric;
    /**
     * The number of bytes put to the Kinesis stream using the PutRecords operation over the specified time period.
     *
     * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
     *
     * @param props properties of the metric
     */
    metricPutRecordsBytes(props?: cloudwatch.MetricOptions): cloudwatch.Metric;
    /**
     * The time taken per PutRecords operation, measured over the specified time period.
     *
     * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
     *
     * @param props properties of the metric
     */
    metricPutRecordsLatency(props?: cloudwatch.MetricOptions): cloudwatch.Metric;
    /**
     *  The number of PutRecords operations where at least one record succeeded, per Kinesis stream, measured over the
     *  specified time period.
     *
     * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
     *
     * @param props properties of the metric
     */
    metricPutRecordsSuccess(props?: cloudwatch.MetricOptions): cloudwatch.Metric;
    /**
     * The total number of records sent in a PutRecords operation per Kinesis data stream, measured over the specified
     * time period.
     *
     * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
     *
     * @param props properties of the metric
     */
    metricPutRecordsTotalRecords(props?: cloudwatch.MetricOptions): cloudwatch.Metric;
    /**
     * The number of successful records in a PutRecords operation per Kinesis data stream, measured over the specified
     * time period.
     *
     * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
     *
     * @param props properties of the metric
     */
    metricPutRecordsSuccessfulRecords(props?: cloudwatch.MetricOptions): cloudwatch.Metric;
    /**
     * The number of records rejected due to internal failures in a PutRecords operation per Kinesis data stream,
     * measured over the specified time period. Occasional internal failures are to be expected and should be retried.
     *
     * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
     *
     * @param props properties of the metric
     */
    metricPutRecordsFailedRecords(props?: cloudwatch.MetricOptions): cloudwatch.Metric;
    /**
     * The number of records rejected due to throttling in a PutRecords operation per Kinesis data stream, measured over
     * the specified time period.
     *
     * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
     *
     * @param props properties of the metric
     */
    metricPutRecordsThrottledRecords(props?: cloudwatch.MetricOptions): cloudwatch.Metric;
    /**
     * The number of GetRecords calls throttled for the stream over the specified time period. The most commonly used
     * statistic for this metric is Average.
     *
     * When the Minimum statistic has a value of 1, all records were throttled for the stream during the specified time
     * period.
     *
     * When the Maximum statistic has a value of 0 (zero), no records were throttled for the stream during the specified
     * time period.
     *
     * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties
     *
     * @param props properties of the metric
     *
     */
    metricReadProvisionedThroughputExceeded(props?: cloudwatch.MetricOptions): cloudwatch.Metric;
    /**
     * The number of records rejected due to throttling for the stream over the specified time period. This metric
     * includes throttling from PutRecord and PutRecords operations.
     *
     * When the Minimum statistic has a non-zero value, records were being throttled for the stream during the specified
     * time period.
     *
     * When the Maximum statistic has a value of 0 (zero), no records were being throttled for the stream during the
     * specified time period.
     *
     * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
     *
     * @param props properties of the metric
     */
    metricWriteProvisionedThroughputExceeded(props?: cloudwatch.MetricOptions): cloudwatch.Metric;
}
/**
 * A reference to a stream. The easiest way to instantiate is to call
 * `stream.export()`. Then, the consumer can use `Stream.import(this, ref)` and
 * get a `Stream`.
 */
export interface StreamAttributes {
    /**
     * The ARN of the stream.
     */
    readonly streamArn: string;
    /**
     * The KMS key securing the contents of the stream if encryption is enabled.
     *
     * @default - No encryption
     */
    readonly encryptionKey?: kms.IKey;
}
/**
 * Represents a Kinesis Stream.
 */
declare abstract class StreamBase extends Resource implements IStream {
    /**
     * The ARN of the stream.
     */
    abstract readonly streamArn: string;
    /**
     * The name of the stream
     */
    abstract readonly streamName: string;
    /**
     * Optional KMS encryption key associated with this stream.
     */
    abstract readonly encryptionKey?: kms.IKey;
    /**
     * Indicates if a stream resource policy should automatically be created upon
     * the first call to `addToResourcePolicy`.
     *
     * Set by subclasses.
     */
    protected abstract readonly autoCreatePolicy: boolean;
    private resourcePolicy?;
    constructor(scope: Construct, id: string, props?: ResourceProps);
    /**
     * Adds a statement to the IAM resource policy associated with this stream.
     *
     * If this stream was created in this stack (`new Stream`), a resource policy
     * will be automatically created upon the first call to `addToResourcePolicy`. If
     * the stream is imported (`Stream.import`), then this is a no-op.
     */
    addToResourcePolicy(statement: iam.PolicyStatement): iam.AddToResourcePolicyResult;
    /**
     * Grant read permissions for this stream and its contents to an IAM
     * principal (Role/Group/User).
     *
     * If an encryption key is used, permission to ues the key to decrypt the
     * contents of the stream will also be granted.
     */
    grantRead(grantee: iam.IGrantable): iam.Grant;
    /**
     * Grant write permissions for this stream and its contents to an IAM
     * principal (Role/Group/User).
     *
     * If an encryption key is used, permission to ues the key to encrypt the
     * contents of the stream will also be granted.
     */
    grantWrite(grantee: iam.IGrantable): iam.Grant;
    /**
     * Grants read/write permissions for this stream and its contents to an IAM
     * principal (Role/Group/User).
     *
     * If an encryption key is used, permission to use the key for
     * encrypt/decrypt will also be granted.
     */
    grantReadWrite(grantee: iam.IGrantable): iam.Grant;
    /**
     * Grant the indicated permissions on this stream to the given IAM principal (Role/Group/User).
     */
    grant(grantee: iam.IGrantable, ...actions: string[]): iam.Grant;
    /**
     * Return stream metric based from its metric name
     *
     * @param metricName name of the stream metric
     * @param props properties of the metric
     */
    metric(metricName: string, props?: cloudwatch.MetricOptions): cloudwatch.Metric;
    /**
     * The number of bytes retrieved from the Kinesis stream, measured over the specified time period. Minimum, Maximum,
     * and Average statistics represent the bytes in a single GetRecords operation for the stream in the specified time
     * period.
     *
     * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
     *
     * @param props properties of the metric
     */
    metricGetRecordsBytes(props?: cloudwatch.MetricOptions): cloudwatch.Metric;
    /**
     * The age of the last record in all GetRecords calls made against a Kinesis stream, measured over the specified time
     * period. Age is the difference between the current time and when the last record of the GetRecords call was written
     * to the stream. The Minimum and Maximum statistics can be used to track the progress of Kinesis consumer
     * applications. A value of zero indicates that the records being read are completely caught up with the stream.
     *
     * The metric defaults to maximum over 5 minutes, it can be changed by passing `statistic` and `period` properties.
     *
     * @param props properties of the metric
     */
    metricGetRecordsIteratorAgeMilliseconds(props?: cloudwatch.MetricOptions): cloudwatch.Metric;
    /**
     * The number of successful GetRecords operations per stream, measured over the specified time period.
     *
     * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
     *
     * @param props properties of the metric
     */
    metricGetRecordsSuccess(props?: cloudwatch.MetricOptions): cloudwatch.Metric;
    /**
     * The number of records retrieved from the shard, measured over the specified time period. Minimum, Maximum, and
     * Average statistics represent the records in a single GetRecords operation for the stream in the specified time
     * period.
     *
     * average
     * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
     *
     * @param props properties of the metric
     */
    metricGetRecords(props?: cloudwatch.MetricOptions): cloudwatch.Metric;
    /**
     * The number of successful GetRecords operations per stream, measured over the specified time period.
     *
     * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
     *
     * @param props properties of the metric
     */
    metricGetRecordsLatency(props?: cloudwatch.MetricOptions): cloudwatch.Metric;
    /**
     * The number of bytes put to the Kinesis stream using the PutRecord operation over the specified time period.
     *
     * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
     *
     * @param props properties of the metric
     */
    metricPutRecordBytes(props?: cloudwatch.MetricOptions): cloudwatch.Metric;
    /**
     * The time taken per PutRecord operation, measured over the specified time period.
     *
     * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
     *
     * @param props properties of the metric
     */
    metricPutRecordLatency(props?: cloudwatch.MetricOptions): cloudwatch.Metric;
    /**
     * The number of successful PutRecord operations per Kinesis stream, measured over the specified time period. Average
     * reflects the percentage of successful writes to a stream.
     *
     * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
     *
     * @param props properties of the metric
     */
    metricPutRecordSuccess(props?: cloudwatch.MetricOptions): cloudwatch.Metric;
    /**
     * The number of bytes put to the Kinesis stream using the PutRecords operation over the specified time period.
     *
     * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
     *
     * @param props properties of the metric
     */
    metricPutRecordsBytes(props?: cloudwatch.MetricOptions): cloudwatch.Metric;
    /**
     * The time taken per PutRecords operation, measured over the specified time period.
     *
     * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
     *
     * @param props properties of the metric
     */
    metricPutRecordsLatency(props?: cloudwatch.MetricOptions): cloudwatch.Metric;
    /**
     *  The number of PutRecords operations where at least one record succeeded, per Kinesis stream, measured over the
     *  specified time period.
     *
     * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
     *
     * @param props properties of the metric
     */
    metricPutRecordsSuccess(props?: cloudwatch.MetricOptions): cloudwatch.Metric;
    /**
     * The total number of records sent in a PutRecords operation per Kinesis data stream, measured over the specified
     * time period.
     *
     * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
     *
     * @param props properties of the metric
     */
    metricPutRecordsTotalRecords(props?: cloudwatch.MetricOptions): cloudwatch.Metric;
    /**
     * The number of successful records in a PutRecords operation per Kinesis data stream, measured over the specified
     * time period.
     *
     * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
     *
     * @param props properties of the metric
     */
    metricPutRecordsSuccessfulRecords(props?: cloudwatch.MetricOptions): cloudwatch.Metric;
    /**
     * The number of records rejected due to internal failures in a PutRecords operation per Kinesis data stream,
     * measured over the specified time period. Occasional internal failures are to be expected and should be retried.
     *
     * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
     *
     * @param props properties of the metric
     */
    metricPutRecordsFailedRecords(props?: cloudwatch.MetricOptions): cloudwatch.Metric;
    /**
     * The number of records rejected due to throttling in a PutRecords operation per Kinesis data stream, measured over
     * the specified time period.
     *
     * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
     *
     * @param props properties of the metric
     */
    metricPutRecordsThrottledRecords(props?: cloudwatch.MetricOptions): cloudwatch.Metric;
    /**
     * The number of bytes successfully put to the Kinesis stream over the specified time period. This metric includes
     * bytes from PutRecord and PutRecords operations. Minimum, Maximum, and Average statistics represent the bytes in a
     * single put operation for the stream in the specified time period.
     *
     * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
     *
     * @param props properties of the metric
     */
    metricIncomingBytes(props?: cloudwatch.MetricOptions): cloudwatch.Metric;
    /**
     * The number of records successfully put to the Kinesis stream over the specified time period. This metric includes
     * record counts from PutRecord and PutRecords operations. Minimum, Maximum, and Average statistics represent the
     * records in a single put operation for the stream in the specified time period.
     *
     * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
     *
     * @param props properties of the metric
     */
    metricIncomingRecords(props?: cloudwatch.MetricOptions): cloudwatch.Metric;
    /**
     * The number of GetRecords calls throttled for the stream over the specified time period. The most commonly used
     * statistic for this metric is Average.
     *
     * When the Minimum statistic has a value of 1, all records were throttled for the stream during the specified time
     * period.
     *
     * When the Maximum statistic has a value of 0 (zero), no records were throttled for the stream during the specified
     * time period.
     *
     * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties
     *
     * @param props properties of the metric
     *
     */
    metricReadProvisionedThroughputExceeded(props?: cloudwatch.MetricOptions): cloudwatch.Metric;
    /**
     * The number of records rejected due to throttling for the stream over the specified time period. This metric
     * includes throttling from PutRecord and PutRecords operations.
     *
     * When the Minimum statistic has a non-zero value, records were being throttled for the stream during the specified
     * time period.
     *
     * When the Maximum statistic has a value of 0 (zero), no records were being throttled for the stream during the
     * specified time period.
     *
     * The metric defaults to average over 5 minutes, it can be changed by passing `statistic` and `period` properties.
     *
     * @param props properties of the metric
     */
    metricWriteProvisionedThroughputExceeded(props?: cloudwatch.MetricOptions): cloudwatch.Metric;
    private metricFromCannedFunction;
}
/**
 * Properties for a Kinesis Stream
 */
export interface StreamProps {
    /**
     * Enforces a particular physical stream name.
     * @default <generated>
     */
    readonly streamName?: string;
    /**
     * The number of hours for the data records that are stored in shards to remain accessible.
     * @default Duration.hours(24)
     */
    readonly retentionPeriod?: Duration;
    /**
     * The number of shards for the stream.
     *
     * Can only be provided if streamMode is Provisioned.
     *
     * @default 1
     */
    readonly shardCount?: number;
    /**
     * The kind of server-side encryption to apply to this stream.
     *
     * If you choose KMS, you can specify a KMS key via `encryptionKey`. If
     * encryption key is not specified, a key will automatically be created.
     *
     * @default - StreamEncryption.KMS if encrypted Streams are supported in the region
     *   or StreamEncryption.UNENCRYPTED otherwise.
     *   StreamEncryption.KMS if an encryption key is supplied through the encryptionKey property
     */
    readonly encryption?: StreamEncryption;
    /**
     * External KMS key to use for stream encryption.
     *
     * The 'encryption' property must be set to "Kms".
     *
     * @default - Kinesis Data Streams master key ('/alias/aws/kinesis').
     *   If encryption is set to StreamEncryption.KMS and this property is undefined, a new KMS key
     *   will be created and associated with this stream.
     */
    readonly encryptionKey?: kms.IKey;
    /**
     * The capacity mode of this stream.
     *
     * @default StreamMode.PROVISIONED
     */
    readonly streamMode?: StreamMode;
    /**
     * Policy to apply when the stream is removed from the stack.
     *
     * @default RemovalPolicy.RETAIN
     */
    readonly removalPolicy?: RemovalPolicy;
}
/**
 * A Kinesis stream. Can be encrypted with a KMS key.
 */
export declare class Stream extends StreamBase {
    /**
     * Import an existing Kinesis Stream provided an ARN
     *
     * @param scope The parent creating construct (usually `this`).
     * @param id The construct's name
     * @param streamArn Stream ARN (i.e. arn:aws:kinesis:<region>:<account-id>:stream/Foo)
     */
    static fromStreamArn(scope: Construct, id: string, streamArn: string): IStream;
    /**
     * Creates a Stream construct that represents an external stream.
     *
     * @param scope The parent creating construct (usually `this`).
     * @param id The construct's name.
     * @param attrs Stream import properties
     */
    static fromStreamAttributes(scope: Construct, id: string, attrs: StreamAttributes): IStream;
    readonly streamArn: string;
    readonly streamName: string;
    readonly encryptionKey?: kms.IKey;
    private readonly stream;
    protected readonly autoCreatePolicy = true;
    constructor(scope: Construct, id: string, props?: StreamProps);
    /**
     * Set up key properties and return the Stream encryption property from the
     * user's configuration.
     */
    private parseEncryption;
}
/**
 * What kind of server-side encryption to apply to this stream
 */
export declare enum StreamEncryption {
    /**
     * Records in the stream are not encrypted.
     */
    UNENCRYPTED = "NONE",
    /**
     * Server-side encryption with a KMS key managed by the user.
     * If `encryptionKey` is specified, this key will be used, otherwise, one will be defined.
     */
    KMS = "KMS",
    /**
     * Server-side encryption with a master key managed by Amazon Kinesis
     */
    MANAGED = "MANAGED"
}
/**
 * Specifies the capacity mode to apply to this stream.
 */
export declare enum StreamMode {
    /**
     * Specify the provisioned capacity mode. The stream will have `shardCount` shards unless
     * modified and will be billed according to the provisioned capacity.
     */
    PROVISIONED = "PROVISIONED",
    /**
     * Specify the on-demand capacity mode. The stream will autoscale and be billed according to the
     * volume of data ingested and retrieved.
     */
    ON_DEMAND = "ON_DEMAND"
}
export {};

```
**Target documentations:**
Ensure generated configurations are tested to follow the following documentation

------------------------
// kinesis_stream.html.markdown
---
subcategory: "Kinesis"
layout: "aws"
page_title: "AWS: aws_kinesis_stream"
description: |-
  Provides a AWS Kinesis Stream
---

### Resource: aws_kinesis_stream

Provides a Kinesis Stream resource. Amazon Kinesis is a managed service that
scales elastically for real-time processing of streaming big data.

For more details, see the [Amazon Kinesis Documentation][1].

#### Example Usage

```terraform
resource "aws_kinesis_stream" "test_stream" {
  name             = "terraform-kinesis-test"
  shard_count      = 1
  retention_period = 48

  shard_level_metrics = [
    "IncomingBytes",
    "OutgoingBytes",
  ]

  stream_mode_details {
    stream_mode = "PROVISIONED"
  }

  tags = {
    Environment = "test"
  }
}
```

#### Argument Reference

This resource supports the following arguments:

* `name` - (Required) A name to identify the stream. This is unique to the AWS account and region the Stream is created in.
* `shard_count` – (Optional) The number of shards that the stream will use. If the `stream_mode` is `PROVISIONED`, this field is required.
Amazon has guidelines for specifying the Stream size that should be referenced when creating a Kinesis stream. See [Amazon Kinesis Streams][2] for more.
* `retention_period` - (Optional) Length of time data records are accessible after they are added to the stream. The maximum value of a stream's retention period is 8760 hours. Minimum value is 24. Default is 24.
* `shard_level_metrics` - (Optional) A list of shard-level CloudWatch metrics which can be enabled for the stream. See [Monitoring with CloudWatch][3] for more. Note that the value ALL should not be used; instead you should provide an explicit list of metrics you wish to enable.
* `enforce_consumer_deletion` - (Optional) A boolean that indicates all registered consumers should be deregistered from the stream so that the stream can be destroyed without error. The default value is `false`.
* `encryption_type` - (Optional) The encryption type to use. The only acceptable values are `NONE` or `KMS`. The default value is `NONE`.
* `kms_key_id` - (Optional) The GUID for the customer-managed KMS key to use for encryption. You can also use a Kinesis-owned master key by specifying the alias `alias/aws/kinesis`.
* `stream_mode_details` - (Optional) Indicates the [capacity mode](https://docs.aws.amazon.com/streams/latest/dev/how-do-i-size-a-stream.html) of the data stream. Detailed below.
* `tags` - (Optional) A map of tags to assign to the resource. If configured with a provider [`default_tags` configuration block](https://registry.terraform.io/providers/hashicorp/aws/latest/docs#default_tags-configuration-block) present, tags with matching keys will overwrite those defined at the provider-level.

##### stream_mode_details Configuration Block

* `stream_mode` - (Required) Specifies the capacity mode of the stream. Must be either `PROVISIONED` or `ON_DEMAND`.

#### Attribute Reference

This resource exports the following attributes in addition to the arguments above:

* `id` - The unique Stream id
* `name` - The unique Stream name
* `shard_count` - The count of Shards for this Stream
* `arn` - The Amazon Resource Name (ARN) specifying the Stream (same as `id`)
* `tags_all` - A map of tags assigned to the resource, including those inherited from the provider [`default_tags` configuration block](https://registry.terraform.io/providers/hashicorp/aws/latest/docs#default_tags-configuration-block).

#### Timeouts

[Configuration options](https://developer.hashicorp.com/terraform/language/resources/syntax#operation-timeouts):

- `create` - (Default `5m`)
- `update` - (Default `120m`)
- `delete` - (Default `120m`)

#### Import

In Terraform v1.5.0 and later, use an [`import` block](https://developer.hashicorp.com/terraform/language/import) to import Kinesis Streams using the `name`. For example:

```terraform
import {
  to = aws_kinesis_stream.test_stream
  id = "terraform-kinesis-test"
}
```

Using `terraform import`, import Kinesis Streams using the `name`. For example:

```console
% terraform import aws_kinesis_stream.test_stream terraform-kinesis-test
```

[1]: https://aws.amazon.com/documentation/kinesis/
[2]: https://docs.aws.amazon.com/kinesis/latest/dev/amazon-kinesis-streams.html
[3]: https://docs.aws.amazon.com/streams/latest/dev/monitoring-with-cloudwatch.html

------------------------

## Simulated Assistant Response
Here are the Unit Tests for TerraConstructs:

```typescript
import {
  kinesisStream,
  kinesisResourcePolicy,
  kmsKey,
  dataAwsIamPolicyDocument,
} from "@cdktf/provider-aws";
import { App, Testing, TerraformVariable, VariableType, Op } from "cdktf";
import "cdktf/lib/testing/adapters/jest";
import { AwsStack } from "../../../src/aws/aws-stack";
import * as kms from "../../../src/aws/encryption";
import * as iam from "../../../src/aws/iam";
import {
  Stream,
  StreamEncryption,
  StreamMode,
} from "../../../src/aws/notify/kinesis-stream";
import { Duration } from "../../../src/duration";
import { Template } from "../../assertions";

const streamTfResource = kinesisStream.KinesisStream.tfResourceType;

const environmentName = "Test";
const gridUUID = "123e4567-e89b-12d3";
const gridUUID2 = "123e4567-e89b-12d4";
const providerConfig = { region: "us-east-1" };
const gridBackendConfig = {
  address: "http://localhost:3000",
};

// Conditional to check if the region is in the list of unsupported regions
const AwsCdkKinesisEncryptedStreamsUnsupportedRegions = `\${contains(["cn-north-1", "cn-northwest-1"], "${providerConfig.region}")}`;

describe("Kinesis data streams", () => {
  let app: App;
  let stack: AwsStack;

  beforeEach(() => {
    app = Testing.app();
    stack = new AwsStack(app, "MyStack", {
      environmentName,
      gridUUID,
      providerConfig,
      gridBackendConfig,
    });
  });

  test("default stream", () => {
    new Stream(stack, "MyStream");

    const t = new Template(stack);
    t.toMatchObject({
      locals: {
        AwsCdkKinesisEncryptedStreamsUnsupportedRegions,
      },
      resource: {
        [streamTfResource]: {
          MyStream_5C050E93: {
            encryption_type:
              '${local.AwsCdkKinesisEncryptedStreamsUnsupportedRegions ? null : "KMS"}',
            kms_key_id:
              '${local.AwsCdkKinesisEncryptedStreamsUnsupportedRegions ? null : "alias/aws/kinesis"}',
            retention_period: 24,
            shard_count: 1,
          },
        },
      },
    });
  }),
    test("multiple default streams only have one condition for encryption", () => {
      new Stream(stack, "MyStream");
      new Stream(stack, "MyOtherStream");

      const t = new Template(stack);
      t.toMatchObject({
        locals: {
          AwsCdkKinesisEncryptedStreamsUnsupportedRegions,
        },
        resource: {
          [streamTfResource]: {
            MyStream_5C050E93: {
              encryption_type:
                '${local.AwsCdkKinesisEncryptedStreamsUnsupportedRegions ? null : "KMS"}',
              kms_key_id:
                '${local.AwsCdkKinesisEncryptedStreamsUnsupportedRegions ? null : "alias/aws/kinesis"}',
              retention_period: 24,
              shard_count: 1,
            },
            MyOtherStream_86FCC9CE: {
              encryption_type:
                '${local.AwsCdkKinesisEncryptedStreamsUnsupportedRegions ? null : "KMS"}',
              kms_key_id:
                '${local.AwsCdkKinesisEncryptedStreamsUnsupportedRegions ? null : "alias/aws/kinesis"}',
              retention_period: 24,
              shard_count: 1,
            },
          },
        },
      });
    }),
    test("stream from attributes", () => {
      const s = Stream.fromStreamAttributes(stack, "MyStream", {
        streamArn: "arn:aws:kinesis:region:account-id:stream/stream-name",
      });

      expect(s.streamArn).toEqual(
        "arn:aws:kinesis:region:account-id:stream/stream-name",
      );
    }),
    test("sets account for imported stream env by fromStreamAttributes", () => {
      const imported = Stream.fromStreamAttributes(stack, "Imported", {
        streamArn:
          "arn:aws:kinesis:us-west-2:999999999999:stream/imported-stream",
      });

      expect(imported.env.account).toEqual("999999999999");
    });

  test("sets region for imported stream env by fromStreamAttributes", () => {
    const imported = Stream.fromStreamAttributes(stack, "Imported", {
      streamArn:
        "arn:aws:kinesis:us-west-2:999999999999:stream/imported-stream",
    });

    expect(imported.env.region).toEqual("us-west-2");
  });

  test("sets account for imported stream env by fromStreamArn", () => {
    const imported = Stream.fromStreamArn(
      stack,
      "Imported",
      "arn:aws:kinesis:us-west-2:999999999999:stream/imported-stream",
    );

    expect(imported.env.account).toEqual("999999999999");
  });

  test("sets region for imported stream env by fromStreamArn", () => {
    const imported = Stream.fromStreamArn(
      stack,
      "Imported",
      "arn:aws:kinesis:us-west-2:123456789012:stream/imported-stream",
    );

    expect(imported.env.region).toEqual("us-west-2");
  });

  test("uses explicit shard count", () => {
    new Stream(stack, "MyStream", {
      shardCount: 2,
    });

    const t = new Template(stack);
    t.expect.toHaveResourceWithProperties(kinesisStream.KinesisStream, {
      shard_count: 2,
    });
  }),
    test("uses explicit retention period", () => {
      new Stream(stack, "MyStream", {
        retentionPeriod: Duration.hours(168),
      });

      const t = new Template(stack);
      t.expect.toHaveResourceWithProperties(kinesisStream.KinesisStream, {
        retention_period: 168,
      });
    }),
    test("retention period must be between 24 and 8760 hours", () => {
      expect(() => {
        new Stream(stack, "MyStream1", {
          retentionPeriod: Duration.hours(8761),
        });
      }).toThrow(
        /retentionPeriod must be between 24 and 8760 hours. Received 8761/,
      );

      expect(() => {
        new Stream(stack, "MyStream2", {
          retentionPeriod: Duration.hours(23),
        });
      }).toThrow(
        /retentionPeriod must be between 24 and 8760 hours. Received 23/,
      );
    }),
    test("uses Kinesis master key if MANAGED encryption type is provided", () => {
      // WHEN
      new Stream(stack, "MyStream", {
        encryption: StreamEncryption.MANAGED,
      });

      // THEN
      const t = new Template(stack);
      t.expect.toHaveResourceWithProperties(kinesisStream.KinesisStream, {
        encryption_type: "KMS",
        kms_key_id: "alias/aws/kinesis",
        retention_period: 24,
        shard_count: 1,
      });
    }),
    test("encryption key cannot be supplied with UNENCRYPTED as the encryption type", () => {
      const key = new kms.Key(stack, "myKey");

      expect(() => {
        new Stream(stack, "MyStream", {
          encryptionKey: key,
          encryption: StreamEncryption.UNENCRYPTED,
        });
      }).toThrow(
        /encryptionKey is specified, so 'encryption' must be set to KMS/,
      );
    }),
    test("if a KMS key is supplied, infers KMS as the encryption type", () => {
      // GIVEN
      const key = new kms.Key(stack, "myKey");

      // WHEN
      new Stream(stack, "myStream", {
        encryptionKey: key,
      });

      // THEN
      const t = new Template(stack);
      t.expect.toHaveResourceWithProperties(kinesisStream.KinesisStream, {
        encryption_type: "KMS",
        kms_key_id: "${aws_kms_key.myKey_441A1E73.arn}",
      });
    }),
    test("auto-creates KMS key if encryption type is KMS but no key is provided", () => {
      const stream = new Stream(stack, "MyStream", {
        encryption: StreamEncryption.KMS,
      });

      const t = new Template(stack);
      t.expect.toHaveResourceWithProperties(kmsKey.KmsKey, {
        description: "Created by MyStack/MyStream",
      });

      t.expect.toHaveResourceWithProperties(kinesisStream.KinesisStream, {
        encryption_type: "KMS",
        kms_key_id: stack.resolve(stream.encryptionKey?.keyArn),
      });
    }),
    test("uses explicit KMS key if encryption type is KMS and a key is provided", () => {
      const explicitKey = new kms.Key(stack, "ExplicitKey", {
        description: "Explicit Key",
      });
      new Stream(stack, "MyStream", {
        encryption: StreamEncryption.KMS,
        encryptionKey: explicitKey,
      });

      const t = new Template(stack);
      t.expect.toHaveResourceWithProperties(kmsKey.KmsKey, {
        description: "Explicit Key",
      });

      t.expect.toHaveResourceWithProperties(kinesisStream.KinesisStream, {
        encryption_type: "KMS",
        kms_key_id: stack.resolve(explicitKey.keyArn),
      });
    }),
    test("uses explicit provisioned streamMode", () => {
      new Stream(stack, "MyStream", {
        streamMode: StreamMode.PROVISIONED,
      });

      const t = new Template(stack);
      t.expect.toHaveResourceWithProperties(kinesisStream.KinesisStream, {
        stream_mode_details: {
          stream_mode: StreamMode.PROVISIONED,
        },
      });
    });

  test("uses explicit on-demand streamMode", () => {
    new Stream(stack, "MyStream", {
      streamMode: StreamMode.ON_DEMAND,
    });

    const t = new Template(stack);
    t.expect.toHaveResourceWithProperties(kinesisStream.KinesisStream, {
      stream_mode_details: {
        stream_mode: StreamMode.ON_DEMAND,
      },
    });
  });

  test("throws when using shardCount with on-demand streamMode", () => {
    expect(() => {
      new Stream(stack, "MyStream", {
        shardCount: 2,
        streamMode: StreamMode.ON_DEMAND,
      });
    }).toThrow(
      `streamMode must be set to ${StreamMode.PROVISIONED} (default) when specifying shardCount`,
    );
  });

  test("grantRead creates and attaches a policy with read only access to the principal", () => {
    const stream = new Stream(stack, "MyStream", {
      encryption: StreamEncryption.KMS,
    });
    const role = new iam.Role(stack, "Role", {
      assumedBy: new iam.AccountPrincipal("000000000000"),
    });
    stream.grantRead(role);

    const t = new Template(stack);
    t.expect.toHaveDataSourceWithProperties(
      dataAwsIamPolicyDocument.DataAwsIamPolicyDocument,
      {
        statement: expect.arrayContaining([
          {
            actions: ["kms:Decrypt"],
            effect: "Allow",
            // ensure the Role gets kms Read permissions on the encryptionKey ARN
            resources: [stack.resolve(stream.encryptionKey?.keyArn)],
          },
        ]),
      },
    );

    t.expect.toHaveResourceWithProperties(kinesisStream.KinesisStream, {
      kms_key_id: stack.resolve(stream.encryptionKey?.keyArn),
    });
  });

  test("grantReadWrite creates and attaches a policy to the principal", () => {
    const stream = new Stream(stack, "MyStream", {
      encryption: StreamEncryption.KMS,
    });
    const role = new iam.Role(stack, "Role", {
      assumedBy: new iam.AccountPrincipal("000000000000"),
    });
    stream.grantReadWrite(role);

    const t = new Template(stack);
    t.expect.toHaveDataSourceWithProperties(
      dataAwsIamPolicyDocument.DataAwsIamPolicyDocument,
      {
        statement: expect.arrayContaining([
          {
            actions: [
              "kms:Decrypt",
              "kms:Encrypt",
              "kms:ReEncrypt*",
              "kms:GenerateDataKey*",
            ],
            effect: "Allow",
            // ensure the Role gets kms ReadWrite permissions on the encryptionKey ARN
            resources: [stack.resolve(stream.encryptionKey?.keyArn)],
          },
        ]),
      },
    );

    t.expect.toHaveResourceWithProperties(kinesisStream.KinesisStream, {
      kms_key_id: stack.resolve(stream.encryptionKey?.keyArn),
    });
  });

  test("grantRead creates and associates a policy with read only access to Stream", () => {
    const stream = new Stream(stack, "MyStream");
    const role = new iam.Role(stack, "Role", {
      assumedBy: new iam.AccountPrincipal("000000000000"),
    });
    stream.grantRead(role);

    const t = new Template(stack);
    t.toMatchObject({
      data: {
        aws_iam_policy_document: {
          Role_AssumeRolePolicy_B27E8126: {
            statement: [
              {
                actions: ["sts:AssumeRole"],
                effect: "Allow",
                principals: [
                  {
                    identifiers: [
                      "arn:${data.aws_partition.Partitition.partition}:iam::000000000000:root",
                    ],
                    type: "AWS",
                  },
                ],
              },
            ],
          },
          Role_DefaultPolicy_2E5E5E0B: {
            statement: [
              {
                actions: [
                  "kinesis:DescribeStreamSummary",
                  "kinesis:GetRecords",
                  "kinesis:GetShardIterator",
                  "kinesis:ListShards",
                  "kinesis:SubscribeToShard",
                  "kinesis:DescribeStream",
                  "kinesis:ListStreams",
                  "kinesis:DescribeStreamConsumer",
                ],
                effect: "Allow",
                resources: ["${aws_kinesis_stream.MyStream_5C050E93.arn}"],
              },
            ],
          },
        },
      },
      locals: {
        AwsCdkKinesisEncryptedStreamsUnsupportedRegions,
      },
      resource: {
        aws_iam_role: {
          Role_1ABCC5F0: {
            assume_role_policy:
              "${data.aws_iam_policy_document.Role_AssumeRolePolicy_B27E8126.json}",
            name_prefix: "123e4567-e89b-12d3-MyStackRole",
          },
        },
        aws_iam_role_policy: {
          Role_DefaultPolicy_ResourceRoles0_50D8AFFD: {
            name: "MyStackRoleDefaultPolicy86F304AD",
            policy:
              "${data.aws_iam_policy_document.Role_DefaultPolicy_2E5E5E0B.json}",
            role: "${aws_iam_role.Role_1ABCC5F0.name}",
          },
        },
        [streamTfResource]: {
          MyStream_5C050E93: {
            retention_period: 24,
            shard_count: 1,
          },
        },
      },
    });
  }),
    test("grantWrite creates and attaches a policy with write only access to Stream", () => {
      const stream = new Stream(stack, "MyStream");
      const role = new iam.Role(stack, "Role", {
        assumedBy: new iam.AccountPrincipal("000000000000"),
      });
      stream.grantWrite(role);

      const t = new Template(stack);
      t.toMatchObject({
        data: {
          aws_iam_policy_document: {
            Role_DefaultPolicy_2E5E5E0B: {
              statement: [
                {
                  actions: [
                    "kinesis:ListShards",
                    "kinesis:PutRecord",
                    "kinesis:PutRecords",
                  ],
                  effect: "Allow",
                  resources: ["${aws_kinesis_stream.MyStream_5C050E93.arn}"],
                },
              ],
            },
          },
        },
        locals: {
          AwsCdkKinesisEncryptedStreamsUnsupportedRegions,
        },
        resource: {
          aws_iam_role: {
            Role_1ABCC5F0: {
              assume_role_policy:
                "${data.aws_iam_policy_document.Role_AssumeRolePolicy_B27E8126.json}",
              name_prefix: "123e4567-e89b-12d3-MyStackRole",
            },
          },
          aws_iam_role_policy: {
            Role_DefaultPolicy_ResourceRoles0_50D8AFFD: {
              name: "MyStackRoleDefaultPolicy86F304AD",
              policy:
                "${data.aws_iam_policy_document.Role_DefaultPolicy_2E5E5E0B.json}",
              role: "${aws_iam_role.Role_1ABCC5F0.name}",
            },
          },
          [streamTfResource]: {
            MyStream_5C050E93: {
              retention_period: 24,
              shard_count: 1,
            },
          },
        },
      });
    }),
    test("grantReadWrite creates and attaches a policy with write only access to Stream", () => {
      const stream = new Stream(stack, "MyStream");
      const role = new iam.Role(stack, "Role", {
        assumedBy: new iam.AccountPrincipal("000000000000"),
      });
      stream.grantReadWrite(role);

      const t = new Template(stack);
      t.toMatchObject({
        data: {
          aws_iam_policy_document: {
            Role_DefaultPolicy_2E5E5E0B: {
              statement: [
                {
                  actions: [
                    "kinesis:DescribeStreamSummary",
                    "kinesis:GetRecords",
                    "kinesis:GetShardIterator",
                    "kinesis:ListShards",
                    "kinesis:SubscribeToShard",
                    "kinesis:DescribeStream",
                    "kinesis:ListStreams",
                    "kinesis:DescribeStreamConsumer",
                    "kinesis:PutRecord",
                    "kinesis:PutRecords",
                  ],
                  effect: "Allow",
                  resources: ["${aws_kinesis_stream.MyStream_5C050E93.arn}"],
                },
              ],
            },
          },
        },
        locals: {
          AwsCdkKinesisEncryptedStreamsUnsupportedRegions,
        },
        resource: {
          aws_iam_role: {
            Role_1ABCC5F0: {
              assume_role_policy:
                "${data.aws_iam_policy_document.Role_AssumeRolePolicy_B27E8126.json}",
              name_prefix: "123e4567-e89b-12d3-MyStackRole",
            },
          },
          aws_iam_role_policy: {
            Role_DefaultPolicy_ResourceRoles0_50D8AFFD: {
              name: "MyStackRoleDefaultPolicy86F304AD",
              policy:
                "${data.aws_iam_policy_document.Role_DefaultPolicy_2E5E5E0B.json}",
              role: "${aws_iam_role.Role_1ABCC5F0.name}",
            },
          },
          [streamTfResource]: {
            MyStream_5C050E93: {
              retention_period: 24,
              shard_count: 1,
            },
          },
        },
      });
    }),
    test("grant creates and attaches a policy to Stream which includes supplied permissions", () => {
      const stream = new Stream(stack, "MyStream");
      const role = new iam.Role(stack, "Role", {
        assumedBy: new iam.AccountPrincipal("000000000000"),
      });
      stream.grant(role, "kinesis:DescribeStream");

      const t = new Template(stack);
      t.toMatchObject({
        data: {
          aws_iam_policy_document: {
            Role_DefaultPolicy_2E5E5E0B: {
              statement: [
                {
                  actions: ["kinesis:DescribeStream"],
                  effect: "Allow",
                  resources: ["${aws_kinesis_stream.MyStream_5C050E93.arn}"],
                },
              ],
            },
          },
        },
        locals: {
          AwsCdkKinesisEncryptedStreamsUnsupportedRegions,
        },
        resource: {
          aws_iam_role: {
            Role_1ABCC5F0: {
              assume_role_policy:
                "${data.aws_iam_policy_document.Role_AssumeRolePolicy_B27E8126.json}",
              name_prefix: "123e4567-e89b-12d3-MyStackRole",
            },
          },
          aws_iam_role_policy: {
            Role_DefaultPolicy_ResourceRoles0_50D8AFFD: {
              name: "MyStackRoleDefaultPolicy86F304AD",
              policy:
                "${data.aws_iam_policy_document.Role_DefaultPolicy_2E5E5E0B.json}",
              role: "${aws_iam_role.Role_1ABCC5F0.name}",
            },
          },
          [streamTfResource]: {
            MyStream_5C050E93: {
              retention_period: 24,
              shard_count: 1,
            },
          },
        },
      });
    }),
    test("cross-stack permissions - no encryption", () => {
      const streamFromStackA = new Stream(stack, "MyStream");

      const stackB = new AwsStack(app, "stackB", {
        environmentName,
        gridUUID: gridUUID2,
        providerConfig,
        gridBackendConfig,
      });
      const role = new iam.Role(stackB, "Role", {
        assumedBy: new iam.AccountPrincipal("000000000000"),
      });
      streamFromStackA.grantRead(role);

      const t = new Template(stackB);
      t.toMatchObject({
        data: {
          aws_iam_policy_document: {
            Role_DefaultPolicy_2E5E5E0B: {
              statement: [
                {
                  actions: [
                    "kinesis:DescribeStreamSummary",
                    "kinesis:GetRecords",
                    "kinesis:GetShardIterator",
                    "kinesis:ListShards",
                    "kinesis:SubscribeToShard",
                    "kinesis:DescribeStream",
                    "kinesis:ListStreams",
                    "kinesis:DescribeStreamConsumer",
                  ],
                  effect: "Allow",
                  resources: [
                    "${data.terraform_remote_state.cross-stack-reference-input-MyStack.outputs.cross-stack-output-aws_kinesis_streamMyStream_5C050E93arn}",
                  ],
                },
              ],
            },
          },
        },
      });
    }),
    test("cross stack permissions - with encryption", () => {
      const streamFromStackA = new Stream(stack, "MyStream", {
        encryption: StreamEncryption.KMS,
      });

      const stackB = new AwsStack(app, "stackB", {
        environmentName,
        gridUUID: gridUUID2,
        providerConfig,
        gridBackendConfig,
      });
      const role = new iam.Role(stackB, "Role", {
        assumedBy: new iam.AccountPrincipal("000000000000"),
      });
      streamFromStackA.grantRead(role);

      const t = new Template(stackB);
      t.toMatchObject({
        data: {
          aws_iam_policy_document: {
            Role_DefaultPolicy_2E5E5E0B: {
              statement: [
                {
                  actions: [
                    "kinesis:DescribeStreamSummary",
                    "kinesis:GetRecords",
                    "kinesis:GetShardIterator",
                    "kinesis:ListShards",
                    "kinesis:SubscribeToShard",
                    "kinesis:DescribeStream",
                    "kinesis:ListStreams",
                    "kinesis:DescribeStreamConsumer",
                  ],
                  effect: "Allow",
                  resources: [
                    "${data.terraform_remote_state.cross-stack-reference-input-MyStack.outputs.cross-stack-output-aws_kinesis_streamMyStream_5C050E93arn}",
                  ],
                },
                {
                  actions: ["kms:Decrypt"],
                  effect: "Allow",
                  // TODO: WRONG? - Cross Stack Dependency cycle prevention?
                  resources: ["*"],
                },
              ],
            },
          },
        },
      });
    });

  test("accepts if retentionPeriodHours is a Token", () => {
    const retentionPeriodVar = new TerraformVariable(
      stack,
      "my-retention-period",
      {
        type: VariableType.NUMBER,
        default: 48,
        // minValue: 24,
        // maxValue: 8760,
      },
    );
    // Just for fun..
    retentionPeriodVar.addValidation({
      condition: Op.gte(retentionPeriodVar.fqn, 24),
      errorMessage: "retentionPeriod must be greater than or equal to 24",
    });
    retentionPeriodVar.addValidation({
      condition: Op.lte(retentionPeriodVar.fqn, 8760),
      errorMessage: "retentionPeriod must be less then or equal to 8760",
    });

    new Stream(stack, "MyStream", {
      retentionPeriod: Duration.hours(retentionPeriodVar.numberValue),
    });

    const t = new Template(stack);
    t.toMatchObject({
      variable: {
        "my-retention-period": {
          default: 48,
          type: "number",
          validation: [
            {
              condition: "${(var.my-retention-period >= 24)}",
              error_message:
                "retentionPeriod must be greater than or equal to 24",
            },
            {
              condition: "${(var.my-retention-period <= 8760)}",
              error_message:
                "retentionPeriod must be less then or equal to 8760",
            },
          ],
        },
      },
      locals: {
        AwsCdkKinesisEncryptedStreamsUnsupportedRegions,
      },
      resource: {
        aws_kinesis_stream: {
          MyStream_5C050E93: {
            encryption_type:
              '${local.AwsCdkKinesisEncryptedStreamsUnsupportedRegions ? null : "KMS"}',
            kms_key_id:
              '${local.AwsCdkKinesisEncryptedStreamsUnsupportedRegions ? null : "alias/aws/kinesis"}',
            name: "123e4567-e89b-12d3MyStackMyStream974B6778",
            retention_period: "${var.my-retention-period}",
            shard_count: 1,
          },
        },
      },
    });
  });

  test("basic stream-level metrics (StreamName dimension only)", () => {
    // GIVEN
    const fiveMinutes = {
      amount: 5,
      unit: {
        label: "minutes",
        isoLabel: "M",
        inMillis: 60000,
      },
    };

    // WHEN
    const stream = new Stream(stack, "MyStream");

    // THEN
    // should resolve the basic metrics (source https://docs.aws.amazon.com/streams/latest/dev/monitoring-with-cloudwatch.html#kinesis-metrics-stream)
    expect(stack.resolve(stream.metricGetRecordsBytes())).toEqual({
      dimensions: {
        StreamName: "${aws_kinesis_stream.MyStream_5C050E93.name}",
      },
      namespace: "AWS/Kinesis",
      metricName: "GetRecords.Bytes",
      period: fiveMinutes,
      region: "us-east-1",
      statistic: "Average",
    });

    expect(
      stack.resolve(stream.metricGetRecordsIteratorAgeMilliseconds()),
    ).toEqual({
      dimensions: {
        StreamName: "${aws_kinesis_stream.MyStream_5C050E93.name}",
      },
      namespace: "AWS/Kinesis",
      metricName: "GetRecords.IteratorAgeMilliseconds",
      period: fiveMinutes,
      region: "us-east-1",
      statistic: "Maximum",
    });

    expect(stack.resolve(stream.metricGetRecordsLatency())).toEqual({
      dimensions: {
        StreamName: "${aws_kinesis_stream.MyStream_5C050E93.name}",
      },
      namespace: "AWS/Kinesis",
      metricName: "GetRecords.Latency",
      period: fiveMinutes,
      region: "us-east-1",
      statistic: "Average",
    });

    expect(stack.resolve(stream.metricGetRecords())).toEqual({
      dimensions: {
        StreamName: "${aws_kinesis_stream.MyStream_5C050E93.name}",
      },
      namespace: "AWS/Kinesis",
      metricName: "GetRecords.Records",
      period: fiveMinutes,
      region: "us-east-1",
      statistic: "Average",
    });

    expect(stack.resolve(stream.metricGetRecordsSuccess())).toEqual({
      dimensions: {
        StreamName: "${aws_kinesis_stream.MyStream_5C050E93.name}",
      },
      namespace: "AWS/Kinesis",
      metricName: "GetRecords.Success",
      period: fiveMinutes,
      region: "us-east-1",
      statistic: "Average",
    });

    expect(stack.resolve(stream.metricIncomingBytes())).toEqual({
      dimensions: {
        StreamName: "${aws_kinesis_stream.MyStream_5C050E93.name}",
      },
      namespace: "AWS/Kinesis",
      metricName: "IncomingBytes",
      period: fiveMinutes,
      region: "us-east-1",
      statistic: "Average",
    });

    expect(stack.resolve(stream.metricIncomingRecords())).toEqual({
      dimensions: {
        StreamName: "${aws_kinesis_stream.MyStream_5C050E93.name}",
      },
      namespace: "AWS/Kinesis",
      metricName: "IncomingRecords",
      period: fiveMinutes,
      region: "us-east-1",
      statistic: "Average",
    });

    expect(stack.resolve(stream.metricPutRecordsBytes())).toEqual({
      dimensions: {
        StreamName: "${aws_kinesis_stream.MyStream_5C050E93.name}",
      },
      namespace: "AWS/Kinesis",
      metricName: "PutRecords.Bytes",
      period: fiveMinutes,
      region: "us-east-1",
      statistic: "Average",
    });

    expect(stack.resolve(stream.metricPutRecordsLatency())).toEqual({
      dimensions: {
        StreamName: "${aws_kinesis_stream.MyStream_5C050E93.name}",
      },
      namespace: "AWS/Kinesis",
      metricName: "PutRecords.Latency",
      period: fiveMinutes,
      region: "us-east-1",
      statistic: "Average",
    });

    expect(stack.resolve(stream.metricPutRecordsSuccess())).toEqual({
      dimensions: {
        StreamName: "${aws_kinesis_stream.MyStream_5C050E93.name}",
      },
      namespace: "AWS/Kinesis",
      metricName: "PutRecords.Success",
      period: fiveMinutes,
      region: "us-east-1",
      statistic: "Average",
    });

    expect(stack.resolve(stream.metricPutRecordsTotalRecords())).toEqual({
      dimensions: {
        StreamName: "${aws_kinesis_stream.MyStream_5C050E93.name}",
      },
      namespace: "AWS/Kinesis",
      metricName: "PutRecords.TotalRecords",
      period: fiveMinutes,
      region: "us-east-1",
      statistic: "Average",
    });

    expect(stack.resolve(stream.metricPutRecordsSuccessfulRecords())).toEqual({
      dimensions: {
        StreamName: "${aws_kinesis_stream.MyStream_5C050E93.name}",
      },
      namespace: "AWS/Kinesis",
      metricName: "PutRecords.SuccessfulRecords",
      period: fiveMinutes,
      region: "us-east-1",
      statistic: "Average",
    });

    expect(stack.resolve(stream.metricPutRecordsFailedRecords())).toEqual({
      dimensions: {
        StreamName: "${aws_kinesis_stream.MyStream_5C050E93.name}",
      },
      namespace: "AWS/Kinesis",
      metricName: "PutRecords.FailedRecords",
      period: fiveMinutes,
      region: "us-east-1",
      statistic: "Average",
    });

    expect(stack.resolve(stream.metricPutRecordsThrottledRecords())).toEqual({
      dimensions: {
        StreamName: "${aws_kinesis_stream.MyStream_5C050E93.name}",
      },
      namespace: "AWS/Kinesis",
      metricName: "PutRecords.ThrottledRecords",
      period: fiveMinutes,
      region: "us-east-1",
      statistic: "Average",
    });

    expect(
      stack.resolve(stream.metricReadProvisionedThroughputExceeded()),
    ).toEqual({
      dimensions: {
        StreamName: "${aws_kinesis_stream.MyStream_5C050E93.name}",
      },
      namespace: "AWS/Kinesis",
      metricName: "ReadProvisionedThroughputExceeded",
      period: fiveMinutes,
      region: "us-east-1",
      statistic: "Average",
    });

    expect(
      stack.resolve(stream.metricWriteProvisionedThroughputExceeded()),
    ).toEqual({
      dimensions: {
        StreamName: "${aws_kinesis_stream.MyStream_5C050E93.name}",
      },
      namespace: "AWS/Kinesis",
      metricName: "WriteProvisionedThroughputExceeded",
      period: fiveMinutes,
      region: "us-east-1",
      statistic: "Average",
    });
  });

  test("allow to overide metric options", () => {
    // GIVEN
    const fiveMinutes = {
      amount: 5,
      unit: {
        label: "minutes",
        isoLabel: "M",
        inMillis: 60000,
      },
    };

    // WHEN
    const stream = new Stream(stack, "MyStream");

    // THEN
    expect(stack.resolve(stream.metricGetRecordsBytes())).toEqual({
      dimensions: {
        StreamName: "${aws_kinesis_stream.MyStream_5C050E93.name}",
      },
      namespace: "AWS/Kinesis",
      metricName: "GetRecords.Bytes",
      period: fiveMinutes,
      region: "us-east-1",
      statistic: "Average",
    });

    expect(
      stack.resolve(
        stream.metricGetRecordsBytes({
          period: Duration.minutes(1),
          statistic: "Maximum",
        }),
      ),
    ).toEqual({
      dimensions: {
        StreamName: "${aws_kinesis_stream.MyStream_5C050E93.name}",
      },
      namespace: "AWS/Kinesis",
      metricName: "GetRecords.Bytes",
      period: { ...fiveMinutes, amount: 1 },
      region: "us-east-1",
      statistic: "Maximum",
    });

    expect(stack.resolve(stream.metricIncomingBytes())).toEqual({
      dimensions: {
        StreamName: "${aws_kinesis_stream.MyStream_5C050E93.name}",
      },
      namespace: "AWS/Kinesis",
      metricName: "IncomingBytes",
      period: fiveMinutes,
      region: "us-east-1",
      statistic: "Average",
    });

    expect(
      stack.resolve(
        stream.metricIncomingBytes({
          period: Duration.minutes(1),
          statistic: "Sum",
        }),
      ),
    ).toEqual({
      dimensions: {
        StreamName: "${aws_kinesis_stream.MyStream_5C050E93.name}",
      },
      namespace: "AWS/Kinesis",
      metricName: "IncomingBytes",
      period: { ...fiveMinutes, amount: 1 },
      region: "us-east-1",
      statistic: "Sum",
    });
  });

  // // TODO: Ensure Terraform MetaData constructor props are set
  // test("with default removal policy", () => {
  //   // WHEN
  //   new Stream(stack, "Stream");

  //   // THEN
  //   stack.prepareStack();
  //   const synthesized = Testing.synth(stack);
  //   // refer to full snapshot for debug
  //   expect(synthesized).toMatchSnapshot();
  //   // Template.fromStack(stack).hasResource("AWS::Kinesis::Stream", {
  //   //   DeletionPolicy: CfnDeletionPolicy.RETAIN,
  //   // });
  // });

  // test("with removal policy as DESTROY", () => {
  //   // WHEN
  //   new Stream(stack, "Stream", {
  //     removalPolicy: RemovalPolicy.DESTROY,
  //   });

  //   // THEN
  //   stack.prepareStack();
  //   const synthesized = Testing.synth(stack);
  //   // refer to full snapshot for debug
  //   expect(synthesized).toMatchSnapshot();
  //   // Template.fromStack(stack).hasResource("AWS::Kinesis::Stream", {
  //   //   DeletionPolicy: CfnDeletionPolicy.DELETE,
  //   // });
  // });

  test("addToResourcePolicy will automatically create a policy for this stream", () => {
    // GIVEN
    const stream = new Stream(stack, "Stream", {});

    // WHEN
    stream.addToResourcePolicy(
      new iam.PolicyStatement({
        actions: ["kinesis:GetRecords"],
        principals: [new iam.AnyPrincipal()],
        resources: [stream.streamArn],
      }),
    );

    // THEN
    const t = new Template(stack);
    t.expect.toHaveDataSourceWithProperties(
      dataAwsIamPolicyDocument.DataAwsIamPolicyDocument,
      {
        statement: [
          {
            actions: ["kinesis:GetRecords"],
            effect: "Allow",
            principals: [
              {
                identifiers: ["*"],
                type: "AWS",
              },
            ],
            resources: [stack.resolve(stream.streamArn)],
          },
        ],
      },
    );
    t.expect.toHaveResourceWithProperties(
      kinesisResourcePolicy.KinesisResourcePolicy,
      {
        policy: "${data.aws_iam_policy_document.Stream_Policy_42FDC357.json}",
        resource_arn: stack.resolve(stream.streamArn),
      },
    );
  });
});

```

## New User Prompt
Convert the following AWS CDK Constructs to TerraConstructs.
```typescript
import { Template } from '../../assertions';
import { App, CfnResource, SecretValue, Stack, Token } from '../../core';
import { Group, ManagedPolicy, Policy, PolicyStatement, User } from '../lib';

describe('IAM user', () => {
  test('default user', () => {
    const app = new App();
    const stack = new Stack(app, 'MyStack');
    new User(stack, 'MyUser');
    Template.fromStack(stack).templateMatches({
      Resources: { MyUserDC45028B: { Type: 'AWS::IAM::User' } },
    });
  });

  test('default user with password', () => {
    const app = new App();
    const stack = new Stack(app, 'MyStack');
    new User(stack, 'MyUser', {
      password: SecretValue.unsafePlainText('1234'),
    });

    Template.fromStack(stack).templateMatches({
      Resources:
      {
        MyUserDC45028B:
        {
          Type: 'AWS::IAM::User',
          Properties: { LoginProfile: { Password: '1234' } },
        },
      },
    });
  });

  test('fails if reset password is required but no password is set', () => {
    const app = new App();
    const stack = new Stack(app, 'MyStack');
    expect(() => new User(stack, 'MyUser', { passwordResetRequired: true })).toThrow();
  });

  test('create with managed policy', () => {
    // GIVEN
    const app = new App();
    const stack = new Stack(app, 'MyStack');

    // WHEN
    new User(stack, 'MyUser', {
      managedPolicies: [ManagedPolicy.fromAwsManagedPolicyName('asdf')],
    });

    // THEN
    Template.fromStack(stack).hasResourceProperties('AWS::IAM::User', {
      ManagedPolicyArns: [
        { 'Fn::Join': ['', ['arn:', { Ref: 'AWS::Partition' }, ':iam::aws:policy/asdf']] },
      ],
    });
  });

  test('can supply permissions boundary managed policy', () => {
    // GIVEN
    const stack = new Stack();

    const permissionsBoundary = ManagedPolicy.fromAwsManagedPolicyName('managed-policy');

    new User(stack, 'MyUser', {
      permissionsBoundary,
    });

    Template.fromStack(stack).hasResourceProperties('AWS::IAM::User', {
      PermissionsBoundary: {
        'Fn::Join': [
          '',
          [
            'arn:',
            {
              Ref: 'AWS::Partition',
            },
            ':iam::aws:policy/managed-policy',
          ],
        ],
      },
    });
  });

  test('user imported by user name has an ARN', () => {
    // GIVEN
    const stack = new Stack();

    // WHEN
    const user = User.fromUserName(stack, 'import', 'MyUserName');

    // THEN
    expect(stack.resolve(user.userArn)).toStrictEqual({
      'Fn::Join': ['', ['arn:', { Ref: 'AWS::Partition' }, ':iam::', { Ref: 'AWS::AccountId' }, ':user/MyUserName']],
    });
  });

  test('user imported by user ARN has a name', () => {
    // GIVEN
    const stack = new Stack();
    const userName = 'MyUserName';

    // WHEN
    const user = User.fromUserArn(stack, 'import', `arn:aws:iam::account-id:user/${userName}`);

    // THEN
    expect(stack.resolve(user.userName)).toStrictEqual(userName);
  });

  test('user imported by tokenized user ARN has a name', () => {
    // GIVEN
    const stack = new Stack();

    // WHEN
    const user = User.fromUserArn(stack, 'import', Token.asString({ Ref: 'ARN' }));

    // THEN
    expect(stack.resolve(user.userName)).toStrictEqual({
      'Fn::Select': [1, { 'Fn::Split': [':user/', { Ref: 'ARN' }] }],
    });
  });

  test('user imported by user ARN has a principalAccount', () => {
    // GIVEN
    const stack = new Stack();
    const accountId = 'account-id';

    // WHEN
    const user = User.fromUserArn(stack, 'import', `arn:aws:iam::${accountId}:user/mockuser`);

    // THEN
    expect(stack.resolve(user.principalAccount)).toStrictEqual(accountId);
  });

  test('user imported by tokenized user ARN has a principalAccount', () => {
    // GIVEN
    const stack = new Stack();

    // WHEN
    const user = User.fromUserArn(stack, 'import', Token.asString({ Ref: 'ARN' }));

    // THEN
    expect(stack.resolve(user.principalAccount)).toStrictEqual({
      'Fn::Select': [4, { 'Fn::Split': [':', { Ref: 'ARN' }] }],
    });
  });
  test('user imported by a new User cosntruct has a principalAccount', () => {
    // GIVEN
    const stack = new Stack();

    // WHEN
    const user = User.fromUserArn(stack, 'import', new User(stack, 'LocalUser').userArn);

    // THEN
    expect(stack.resolve(user.principalAccount)).toStrictEqual(
      { 'Fn::Select': [4, { 'Fn::Split': [':', { 'Fn::GetAtt': ['LocalUser87F70DDF', 'Arn'] }] }] },
    );
  });

  test('user imported by user ARN with path', () => {
    // GIVEN
    const stack = new Stack();
    const userName = 'MyUserName';

    // WHEN
    const user = User.fromUserArn(stack, 'import', `arn:aws:iam::account-id:user/path/${userName}`);

    // THEN
    expect(stack.resolve(user.userName)).toStrictEqual(userName);
  });

  test('user imported by user ARN with path (multiple elements)', () => {
    // GIVEN
    const stack = new Stack();
    const userName = 'MyUserName';

    // WHEN
    const user = User.fromUserArn(stack, 'import', `arn:aws:iam::account-id:user/p/a/t/h/${userName}`);

    // THEN
    expect(stack.resolve(user.userName)).toStrictEqual(userName);
  });

  test('user imported by tokenized user attributes has a name', () => {
    // GIVEN
    const stack = new Stack();

    // WHEN
    const user = User.fromUserAttributes(stack, 'import', {
      userArn: Token.asString({ Ref: 'ARN' }),
    });

    // THEN
    expect(stack.resolve(user.userName)).toStrictEqual({
      'Fn::Select': [1, { 'Fn::Split': [':user/', { Ref: 'ARN' }] }],
    });
  });

  test('user imported by user attributes has a name', () => {
    // GIVEN
    const stack = new Stack();
    const userName = 'MyUserName';

    // WHEN
    const user = User.fromUserAttributes(stack, 'import', {
      userArn: `arn:aws:iam::account-id:user/${userName}`,
    });

    // THEN
    expect(stack.resolve(user.userName)).toStrictEqual(userName);
  });

  test('user imported by user attributes with path has a name', () => {
    // GIVEN
    const stack = new Stack();
    const userName = 'MyUserName';

    // WHEN
    const user = User.fromUserAttributes(stack, 'import', {
      userArn: `arn:aws:iam::account-id:user/path/${userName}`,
    });

    // THEN
    expect(stack.resolve(user.userName)).toStrictEqual(userName);
  });

  test('user imported by user attributes with path (multiple elements) has a name', () => {
    // GIVEN
    const stack = new Stack();
    const userName = 'MyUserName';

    // WHEN
    const user = User.fromUserAttributes(stack, 'import', {
      userArn: `arn:aws:iam::account-id:user/p/a/t/h/${userName}`,
    });

    // THEN
    expect(stack.resolve(user.userName)).toStrictEqual(userName);
  });

  test('add to policy of imported user', () => {
    // GIVEN
    const stack = new Stack();
    const user = User.fromUserName(stack, 'ImportedUser', 'john');

    // WHEN
    user.addToPrincipalPolicy(new PolicyStatement({
      actions: ['aws:Use'],
      resources: ['*'],
    }));

    // THEN
    Template.fromStack(stack).hasResourceProperties('AWS::IAM::Policy', {
      Users: ['john'],
      PolicyDocument: {
        Statement: [
          {
            Action: 'aws:Use',
            Effect: 'Allow',
            Resource: '*',
          },
        ],
        Version: '2012-10-17',
      },
    });
  });

  test('attach policy to imported user', () => {
    // GIVEN
    const stack = new Stack();
    const user = User.fromUserName(stack, 'ImportedUser', 'john');

    // WHEN
    user.attachInlinePolicy(new Policy(stack, 'Policy', {
      statements: [
        new PolicyStatement({
          actions: ['aws:Use'],
          resources: ['*'],
        }),
      ],
    }));

    // THEN
    Template.fromStack(stack).hasResourceProperties('AWS::IAM::Policy', {
      Users: ['john'],
      PolicyDocument: {
        Statement: [
          {
            Action: 'aws:Use',
            Effect: 'Allow',
            Resource: '*',
          },
        ],
        Version: '2012-10-17',
      },
    });
  });

  test('addToGroup for imported user', () => {
    // GIVEN
    const stack = new Stack();
    const user = User.fromUserName(stack, 'ImportedUser', 'john');
    const group = new Group(stack, 'Group');
    const otherGroup = new Group(stack, 'OtherGroup');

    // WHEN
    user.addToGroup(group);
    otherGroup.addUser(user);

    // THEN
    Template.fromStack(stack).hasResourceProperties('AWS::IAM::UserToGroupAddition', {
      GroupName: {
        Ref: 'GroupC77FDACD',
      },
      Users: [
        'john',
      ],
    });

    Template.fromStack(stack).hasResourceProperties('AWS::IAM::UserToGroupAddition', {
      GroupName: {
        Ref: 'OtherGroup85E5C653',
      },
      Users: [
        'john',
      ],
    });
  });
});

test('cross-env user ARNs include path', () => {
  const app = new App();
  const userStack = new Stack(app, 'user-stack', { env: { account: '123456789012', region: 'us-east-1' } });
  const referencerStack = new Stack(app, 'referencer-stack', { env: { region: 'us-east-2' } });
  const user = new User(userStack, 'User', {
    path: '/sample/path/',
    userName: 'sample-name',
  });
  new CfnResource(referencerStack, 'Referencer', {
    type: 'Custom::UserReferencer',
    properties: { UserArn: user.userArn },
  });

  Template.fromStack(referencerStack).hasResourceProperties('Custom::UserReferencer', {
    UserArn: {
      'Fn::Join': [
        '',
        [
          'arn:',
          {
            Ref: 'AWS::Partition',
          },
          ':iam::123456789012:user/sample/path/sample-name',
        ],
      ],
    },
  });
});

```

## Reference Documents
**AWS CDK Tested Construct Type Declarations:**
Refer to the following Reference declarations used by the AWSCDK constructs:
```typescript
// user.d.ts
import { Construct } from 'constructs';
import { IGroup } from './group';
import { IIdentity } from './identity-base';
import { IManagedPolicy } from './managed-policy';
import { Policy } from './policy';
import { PolicyStatement } from './policy-statement';
import { AddToPrincipalPolicyResult, IPrincipal, PrincipalPolicyFragment } from './principals';
import { Resource, SecretValue } from '../../core';
/**
 * Represents an IAM user
 *
 * @see https://docs.aws.amazon.com/IAM/latest/UserGuide/id_users.html
 */
export interface IUser extends IIdentity {
    /**
     * The user's name
     * @attribute
     */
    readonly userName: string;
    /**
     * The user's ARN
     * @attribute
     */
    readonly userArn: string;
    /**
     * Adds this user to a group.
     */
    addToGroup(group: IGroup): void;
}
/**
 * Properties for defining an IAM user
 */
export interface UserProps {
    /**
     * Groups to add this user to. You can also use `addToGroup` to add this
     * user to a group.
     *
     * @default - No groups.
     */
    readonly groups?: IGroup[];
    /**
     * A list of managed policies associated with this role.
     *
     * You can add managed policies later using
     * `addManagedPolicy(ManagedPolicy.fromAwsManagedPolicyName(policyName))`.
     *
     * @default - No managed policies.
     */
    readonly managedPolicies?: IManagedPolicy[];
    /**
     * The path for the user name. For more information about paths, see IAM
     * Identifiers in the IAM User Guide.
     *
     * @default /
     */
    readonly path?: string;
    /**
     * AWS supports permissions boundaries for IAM entities (users or roles).
     * A permissions boundary is an advanced feature for using a managed policy
     * to set the maximum permissions that an identity-based policy can grant to
     * an IAM entity. An entity's permissions boundary allows it to perform only
     * the actions that are allowed by both its identity-based policies and its
     * permissions boundaries.
     *
     * @link https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-role.html#cfn-iam-role-permissionsboundary
     * @link https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_boundaries.html
     *
     * @default - No permissions boundary.
     */
    readonly permissionsBoundary?: IManagedPolicy;
    /**
     * A name for the IAM user. For valid values, see the UserName parameter for
     * the CreateUser action in the IAM API Reference. If you don't specify a
     * name, AWS CloudFormation generates a unique physical ID and uses that ID
     * for the user name.
     *
     * If you specify a name, you cannot perform updates that require
     * replacement of this resource. You can perform updates that require no or
     * some interruption. If you must replace the resource, specify a new name.
     *
     * If you specify a name, you must specify the CAPABILITY_NAMED_IAM value to
     * acknowledge your template's capabilities. For more information, see
     * Acknowledging IAM Resources in AWS CloudFormation Templates.
     *
     * @default - Generated by CloudFormation (recommended)
     */
    readonly userName?: string;
    /**
     * The password for the user. This is required so the user can access the
     * AWS Management Console.
     *
     * You can use `SecretValue.unsafePlainText` to specify a password in plain text or
     * use `secretsmanager.Secret.fromSecretAttributes` to reference a secret in
     * Secrets Manager.
     *
     * @default - User won't be able to access the management console without a password.
     */
    readonly password?: SecretValue;
    /**
     * Specifies whether the user is required to set a new password the next
     * time the user logs in to the AWS Management Console.
     *
     * If this is set to 'true', you must also specify "initialPassword".
     *
     * @default false
     */
    readonly passwordResetRequired?: boolean;
}
/**
 * Represents a user defined outside of this stack.
 */
export interface UserAttributes {
    /**
     * The ARN of the user.
     *
     * Format: arn:<partition>:iam::<account-id>:user/<user-name-with-path>
     */
    readonly userArn: string;
}
/**
 * Define a new IAM user
 */
export declare class User extends Resource implements IIdentity, IUser {
    /**
     * Import an existing user given a username.
     *
     * @param scope construct scope
     * @param id construct id
     * @param userName the username of the existing user to import
     */
    static fromUserName(scope: Construct, id: string, userName: string): IUser;
    /**
     * Import an existing user given a user ARN.
     *
     * If the ARN comes from a Token, the User cannot have a path; if so, any attempt
     * to reference its username will fail.
     *
     * @param scope construct scope
     * @param id construct id
     * @param userArn the ARN of an existing user to import
     */
    static fromUserArn(scope: Construct, id: string, userArn: string): IUser;
    /**
     * Import an existing user given user attributes.
     *
     * If the ARN comes from a Token, the User cannot have a path; if so, any attempt
     * to reference its username will fail.
     *
     * @param scope construct scope
     * @param id construct id
     * @param attrs the attributes of the user to import
     */
    static fromUserAttributes(scope: Construct, id: string, attrs: UserAttributes): IUser;
    readonly grantPrincipal: IPrincipal;
    readonly principalAccount: string | undefined;
    readonly assumeRoleAction: string;
    /**
     * An attribute that represents the user name.
     * @attribute
     */
    readonly userName: string;
    /**
     * An attribute that represents the user's ARN.
     * @attribute
     */
    readonly userArn: string;
    /**
     * Returns the permissions boundary attached  to this user
     */
    readonly permissionsBoundary?: IManagedPolicy;
    readonly policyFragment: PrincipalPolicyFragment;
    private readonly groups;
    private readonly managedPolicies;
    private readonly attachedPolicies;
    private defaultPolicy?;
    constructor(scope: Construct, id: string, props?: UserProps);
    /**
     * Adds this user to a group.
     */
    addToGroup(group: IGroup): void;
    /**
     * Attaches a managed policy to the user.
     * @param policy The managed policy to attach.
     */
    addManagedPolicy(policy: IManagedPolicy): void;
    /**
     * Attaches a policy to this user.
     */
    attachInlinePolicy(policy: Policy): void;
    /**
     * Adds an IAM statement to the default policy.
     *
     * @returns true
     */
    addToPrincipalPolicy(statement: PolicyStatement): AddToPrincipalPolicyResult;
    addToPolicy(statement: PolicyStatement): boolean;
    private parseLoginProfile;
}

```
**Target documentations:**
Ensure generated configurations are tested to follow the following documentation

------------------------
// iam_user.html.markdown
---
subcategory: "IAM (Identity & Access Management)"
layout: "aws"
page_title: "AWS: aws_iam_user"
description: |-
  Provides an IAM user.
---

### Resource: aws_iam_user

Provides an IAM user.

~> *NOTE:* If policies are attached to the user via the [`aws_iam_policy_attachment` resource](/docs/providers/aws/r/iam_policy_attachment.html) and you are modifying the user `name` or `path`, the `force_destroy` argument must be set to `true` and applied before attempting the operation otherwise you will encounter a `DeleteConflict` error. The [`aws_iam_user_policy_attachment` resource (recommended)](/docs/providers/aws/r/iam_user_policy_attachment.html) does not have this requirement.

#### Example Usage

```terraform
resource "aws_iam_user" "lb" {
  name = "loadbalancer"
  path = "/system/"

  tags = {
    tag-key = "tag-value"
  }
}

resource "aws_iam_access_key" "lb" {
  user = aws_iam_user.lb.name
}

data "aws_iam_policy_document" "lb_ro" {
  statement {
    effect    = "Allow"
    actions   = ["ec2:Describe*"]
    resources = ["*"]
  }
}

resource "aws_iam_user_policy" "lb_ro" {
  name   = "test"
  user   = aws_iam_user.lb.name
  policy = data.aws_iam_policy_document.lb_ro.json
}
```

#### Argument Reference

This resource supports the following arguments:

* `name` - (Required) The user's name. The name must consist of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: `=,.@-_.`. User names are not distinguished by case. For example, you cannot create users named both "TESTUSER" and "testuser".
* `path` - (Optional, default "/") Path in which to create the user.
* `permissions_boundary` - (Optional) The ARN of the policy that is used to set the permissions boundary for the user.
* `force_destroy` - (Optional, default false) When destroying this user, destroy even if it
  has non-Terraform-managed IAM access keys, login profile or MFA devices. Without `force_destroy`
  a user with non-Terraform-managed access keys and login profile will fail to be destroyed.
* `tags` - Key-value map of tags for the IAM user. If configured with a provider [`default_tags` configuration block](https://registry.terraform.io/providers/hashicorp/aws/latest/docs#default_tags-configuration-block) present, tags with matching keys will overwrite those defined at the provider-level.

#### Attribute Reference

This resource exports the following attributes in addition to the arguments above:

* `arn` - The ARN assigned by AWS for this user.
* `id` - The user's name.
* `name` - The user's name.
* `tags_all` - A map of tags assigned to the resource, including those inherited from the provider [`default_tags` configuration block](https://registry.terraform.io/providers/hashicorp/aws/latest/docs#default_tags-configuration-block).
* `unique_id` - The [unique ID][1] assigned by AWS.

  [1]: https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html#GUIDs

#### Import

In Terraform v1.5.0 and later, use an [`import` block](https://developer.hashicorp.com/terraform/language/import) to import IAM Users using the `name`. For example:

```terraform
import {
  to = aws_iam_user.lb
  id = "loadbalancer"
}
```

Using `terraform import`, import IAM Users using the `name`. For example:

```console
% terraform import aws_iam_user.lb loadbalancer
```


// iam_user_policy.html.markdown
---
subcategory: "IAM (Identity & Access Management)"
layout: "aws"
page_title: "AWS: aws_iam_user_policy"
description: |-
  Provides an IAM policy attached to a user.
---

### Resource: aws_iam_user_policy

Provides an IAM policy attached to a user.

~> **NOTE:** We suggest using [`jsonencode()`](https://developer.hashicorp.com/terraform/language/functions/jsonencode) or [`aws_iam_policy_document`](/docs/providers/aws/d/iam_policy_document.html) when assigning a value to `policy`. They seamlessly translate Terraform language into JSON, enabling you to maintain consistency within your configuration without the need for context switches. Also, you can sidestep potential complications arising from formatting discrepancies, whitespace inconsistencies, and other nuances inherent to JSON.

#### Example Usage

```terraform
resource "aws_iam_user_policy" "lb_ro" {
  name = "test"
  user = aws_iam_user.lb.name

  # Terraform's "jsonencode" function converts a
  # Terraform expression result to valid JSON syntax.
  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Action = [
          "ec2:Describe*",
        ]
        Effect   = "Allow"
        Resource = "*"
      },
    ]
  })
}

resource "aws_iam_user" "lb" {
  name = "loadbalancer"
  path = "/system/"
}

resource "aws_iam_access_key" "lb" {
  user = aws_iam_user.lb.name
}
```

#### Argument Reference

This resource supports the following arguments:

* `policy` - (Required) The policy document. This is a JSON formatted string. For more information about building AWS IAM policy documents with Terraform, see the [AWS IAM Policy Document Guide](https://learn.hashicorp.com/terraform/aws/iam-policy).
* `name` - (Optional) The name of the policy. If omitted, Terraform will assign a random, unique name.
* `name_prefix` - (Optional, Forces new resource) Creates a unique name beginning with the specified prefix. Conflicts with `name`.
* `user` - (Required) IAM user to which to attach this policy.

#### Attribute Reference

This resource exports the following attributes in addition to the arguments above:

* `id` - The user policy ID, in the form of `user_name:user_policy_name`.
* `name` - The name of the policy (always set).

#### Import

In Terraform v1.5.0 and later, use an [`import` block](https://developer.hashicorp.com/terraform/language/import) to import IAM User Policies using the `user_name:user_policy_name`. For example:

```terraform
import {
  to = aws_iam_user_policy.mypolicy
  id = "user_of_mypolicy_name:mypolicy_name"
}
```

Using `terraform import`, import IAM User Policies using the `user_name:user_policy_name`. For example:

```console
% terraform import aws_iam_user_policy.mypolicy user_of_mypolicy_name:mypolicy_name
```


// iam_user_policy_attachment.html.markdown
---
subcategory: "IAM (Identity & Access Management)"
layout: "aws"
page_title: "AWS: aws_iam_user_policy_attachment"
description: |-
  Attaches a Managed IAM Policy to an IAM user
---

### Resource: aws_iam_user_policy_attachment

Attaches a Managed IAM Policy to an IAM user

~> **NOTE:** The usage of this resource conflicts with the `aws_iam_policy_attachment` resource and will permanently show a difference if both are defined.

#### Example Usage

```terraform
resource "aws_iam_user" "user" {
  name = "test-user"
}

resource "aws_iam_policy" "policy" {
  name        = "test-policy"
  description = "A test policy"
  policy      = "{ ... policy JSON ... }"
}

resource "aws_iam_user_policy_attachment" "test-attach" {
  user       = aws_iam_user.user.name
  policy_arn = aws_iam_policy.policy.arn
}
```

#### Argument Reference

This resource supports the following arguments:

* `user`        (Required) - The user the policy should be applied to
* `policy_arn`  (Required) - The ARN of the policy you want to apply

#### Attribute Reference

This resource exports no additional attributes.

#### Import

In Terraform v1.5.0 and later, use an [`import` block](https://developer.hashicorp.com/terraform/language/import) to import IAM user policy attachments using the user name and policy arn separated by `/`. For example:

```terraform
import {
  to = aws_iam_user_policy_attachment.test-attach
  id = "test-user/arn:aws:iam::xxxxxxxxxxxx:policy/test-policy"
}
```

Using `terraform import`, import IAM user policy attachments using the user name and policy arn separated by `/`. For example:

```console
% terraform import aws_iam_user_policy_attachment.test-attach test-user/arn:aws:iam::xxxxxxxxxxxx:policy/test-policy
```


// iam_user_ssh_key.html.markdown
---
subcategory: "IAM (Identity & Access Management)"
layout: "aws"
page_title: "AWS: aws_iam_user_ssh_key"
description: |-
  Uploads an SSH public key and associates it with the specified IAM user.
---

### Resource: aws_iam_user_ssh_key

Uploads an SSH public key and associates it with the specified IAM user.

#### Example Usage

```terraform
resource "aws_iam_user" "user" {
  name = "test-user"
  path = "/"
}

resource "aws_iam_user_ssh_key" "user" {
  username   = aws_iam_user.user.name
  encoding   = "SSH"
  public_key = "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQD3F6tyPEFEzV0LX3X8BsXdMsQz1x2cEikKDEY0aIj41qgxMCP/iteneqXSIFZBp5vizPvaoIR3Um9xK7PGoW8giupGn+EPuxIA4cDM4vzOqOkiMPhz5XK0whEjkVzTo4+S0puvDZuwIsdiW9mxhJc7tgBNL0cYlWSYVkz4G/fslNfRPW5mYAM49f4fhtxPb5ok4Q2Lg9dPKVHO/Bgeu5woMc7RY0p1ej6D4CKFE6lymSDJpW0YHX/wqE9+cfEauh7xZcG0q9t2ta6F6fmX0agvpFyZo8aFbXeUBr7osSCJNgvavWbM/06niWrOvYX2xwWdhXmXSrbX8ZbabVohBK41 mytest@mydomain.com"
}
```

#### Argument Reference

This resource supports the following arguments:

* `username` - (Required) The name of the IAM user to associate the SSH public key with.
* `encoding` - (Required) Specifies the public key encoding format to use in the response. To retrieve the public key in ssh-rsa format, use `SSH`. To retrieve the public key in PEM format, use `PEM`.
* `public_key` - (Required) The SSH public key. The public key must be encoded in ssh-rsa format or PEM format.
* `status` - (Optional) The status to assign to the SSH public key. Active means the key can be used for authentication with an AWS CodeCommit repository. Inactive means the key cannot be used. Default is `active`.

#### Attribute Reference

This resource exports the following attributes in addition to the arguments above:

* `ssh_public_key_id` - The unique identifier for the SSH public key.
* `fingerprint` - The MD5 message digest of the SSH public key.

#### Import

In Terraform v1.5.0 and later, use an [`import` block](https://developer.hashicorp.com/terraform/language/import) to import SSH public keys using the `username`, `ssh_public_key_id`, and `encoding`. For example:

```terraform
import {
  to = aws_iam_user_ssh_key.user
  id = "user:APKAJNCNNJICVN7CFKCA:SSH"
}
```

Using `terraform import`, import SSH public keys using the `username`, `ssh_public_key_id`, and `encoding`. For example:

```console
% terraform import aws_iam_user_ssh_key.user user:APKAJNCNNJICVN7CFKCA:SSH
```

------------------------
